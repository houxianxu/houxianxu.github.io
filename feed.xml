<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://houxianxu.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://houxianxu.github.io/" rel="alternate" type="text/html" /><updated>2025-07-10T13:55:53+00:00</updated><id>http://houxianxu.github.io/feed.xml</id><title type="html">Xianxu Hou</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">CNN Face Detection</title><link href="http://houxianxu.github.io/blog/2015/CNN-Face-Detection/" rel="alternate" type="text/html" title="CNN Face Detection" /><published>2015-12-07T00:00:00+00:00</published><updated>2015-12-07T00:00:00+00:00</updated><id>http://houxianxu.github.io/blog/2015/CNN-Face-Detection</id><content type="html" xml:base="http://houxianxu.github.io/blog/2015/CNN-Face-Detection/"><![CDATA[<p>The post records some notes for CNN Face Detection project in my PhD in the University of Nottingham.</p>

<h3 id="note-1-make-image-square-and-cropsplit-it-into-sub_images">Note 1: Make image square and crop/split it into sub_images</h3>
<p><strong>Make image square</strong></p>

<p>In order to use Convolutional Neural Network that (mostly) requires the input image square, i.e. of shape (3, N, N), I need to make the height equals to width. There are 3 ways coming into my mind:</p>

<ul>
  <li>Stretch the image to square, <strong>not good</strong> because the face could be stretched.</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">cv2</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">stretch_to_square</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">resize</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></code></pre></figure>

<ul>
  <li>Crop the image to square, usually set the cropped size as the smaller one of width and height. <strong>Not good</strong> because information could be lost</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">crop_to_square</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">x_size</span> <span class="n">y_size</span><span class="p">:</span>
        <span class="c1"># landscape
</span>        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_size</span> <span class="o">-</span> <span class="n">y_size</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">frame</span><span class="p">[:,</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">y_size</span><span class="p">,:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># portrait
</span>        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_size</span> <span class="o">-</span> <span class="n">x_size</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">frame</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x_size</span><span class="p">,:,:]</span></code></pre></figure>

<ul>
  <li>Padded the image with zeros to square, <strong>better solution</strong>. However we need to store the padded size in order to convert from padded image coordinates to original image coordinates. We can define a new class SuperImage to achieve this.</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">padding_to_square</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">bookkeeping</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">up_scale</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">y_size</span> <span class="o">==</span> <span class="n">x_size</span><span class="p">:</span>
        <span class="n">padded_frame</span> <span class="o">=</span> <span class="n">frame</span>
        <span class="n">super_image</span> <span class="o">=</span> <span class="nc">SuperImage</span><span class="p">(</span><span class="n">padded_frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y_size</span> <span class="n">x_size</span><span class="p">:</span>
        <span class="n">pad_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_size</span> <span class="o">-</span> <span class="n">x_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">pad_after</span> <span class="o">=</span> <span class="n">y_size</span> <span class="o">-</span> <span class="n">x_size</span> <span class="o">-</span> <span class="n">pad_before</span>
        <span class="n">padded_frame</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">pad</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">constant</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">up_scale</span><span class="p">:</span>  <span class="c1"># up scale the image, more padding if needed
</span>            <span class="n">pad</span> <span class="o">=</span> <span class="n">y_size</span> <span class="o">//</span> <span class="n">up_scale</span>
            <span class="n">padded_frame</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">pad</span><span class="p">(</span><span class="n">padded_frame</span><span class="p">,</span> <span class="p">((</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">constant</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">super_image</span> <span class="o">=</span> <span class="nc">SuperImage</span><span class="p">(</span><span class="n">padded_frame</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad_before</span> <span class="o">+</span> <span class="n">pad</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y_size</span> <span class="o">&lt;</span> <span class="n">x_size</span><span class="p">:</span>
        <span class="n">pad_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_size</span> <span class="o">-</span> <span class="n">y_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">pad_after</span> <span class="o">=</span> <span class="n">x_size</span> <span class="o">-</span> <span class="n">y_size</span> <span class="o">-</span> <span class="n">pad_before</span>
        <span class="n">padded_frame</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">pad</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">constant</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">up_scale</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">x_size</span> <span class="o">//</span> <span class="n">up_scale</span>
            <span class="n">padded_frame</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">pad</span><span class="p">(</span><span class="n">padded_frame</span><span class="p">,</span> <span class="p">((</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">constant</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">super_image</span> <span class="o">=</span> <span class="nc">SuperImage</span><span class="p">(</span><span class="n">padded_frame</span><span class="p">,</span> <span class="n">pad_before</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">pad</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bookkeeping</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">super_image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">padded_frame</span>

<span class="k">class</span> <span class="nc">SuperImage</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Store the current position of a super_image (after padding) </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        - image: an array, represent the sub image
        - y: int to represent the top coordinate in the parent image
        - x: int to represent the left coordinate in the parent image
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">SuperImage</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sup_y0</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sup_x0</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">old_x_y</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> convert (y, x) in the super image to the parent / old image coordinate system </span><span class="sh">"""</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">sup_y0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">sup_x0</span><span class="p">)</span></code></pre></figure>

<p><strong>Split image into sub_images</strong></p>

<p>For simplicity (because simple is good), I use sliding window to split images. I design to overlap the sub_images to make sure any two continuous pixels can appear at least one sub_image. Specifically, if I want to get n*n sub_images, then set <code class="language-plaintext highlighter-rouge">stride = int(1.0/n * height)</code>, and sub_image size <code class="language-plaintext highlighter-rouge">sub_size = 2 * stride</code> to overlap half of the sub_images. If the size of remains are not enough to form a sub_image, we can add zero_padding or just throw them away.
In addition, we can use SubImage Class to store the information to convert sub_image coordinates back to original image.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">split_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">stride_ratio</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">pad_to_fit</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> split to n*n SubImages based on window sliding </span><span class="sh">"""</span>
    <span class="c1"># make the image square
</span>    <span class="n">sub_images</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">square_image</span> <span class="o">=</span> <span class="nf">padding_to_square</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">square_image</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">stride_ratio</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span>
    <span class="n">sub_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stride</span>
    <span class="n">padding_image</span> <span class="o">=</span> <span class="n">square_image</span>
    <span class="k">if</span> <span class="n">pad_to_fit</span><span class="p">:</span>
        <span class="c1"># decide how much padding need to make sure the sliding "fit" across input neatly
</span>        <span class="c1"># it is like the zero_padding in the convolutional layer
</span>        <span class="n">n</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="n">stride</span>
        <span class="n">remain_size</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">stride</span>
        <span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">remain_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># need zero_padding, note: here should include 0 to make sure every image has the same number of sub images
</span>            <span class="n">pad_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">stride</span> <span class="o">-</span> <span class="n">remain_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># may not be even
</span>            <span class="n">pad_after</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">-</span> <span class="n">remain_size</span> <span class="o">-</span> <span class="n">pad_before</span>
            <span class="n">padding_image</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">pad</span><span class="p">(</span><span class="n">square_image</span><span class="p">,</span> <span class="p">((</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">constant</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padding_image</span> <span class="o">=</span> <span class="n">square_image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">print</span> <span class="sh">'</span><span class="s">pad</span><span class="sh">'</span><span class="p">,</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">pad_after</span>
    <span class="n">pad_image_size</span> <span class="o">=</span> <span class="n">padding_image</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_image_size</span><span class="o">-</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span> 
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_image_size</span><span class="o">-</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">sub_size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pad_image_size</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sub_size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pad_image_size</span><span class="p">:</span>  <span class="c1"># not pad to fit 
</span>                <span class="n">sub_image</span> <span class="o">=</span> <span class="n">padding_image</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">+</span><span class="n">sub_size</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">sub_size</span><span class="p">,</span> <span class="p">:].</span><span class="nf">copy</span><span class="p">()</span>
                <span class="c1"># we need the original not the padded image in above when pad_to_fit
</span>                <span class="n">sub_image</span> <span class="o">=</span> <span class="nc">SubImage</span><span class="p">(</span><span class="n">sub_image</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">pad_before</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">pad_before</span><span class="p">)</span>  <span class="c1"># it is a little ugly, but it works
</span>                <span class="n">sub_images</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sub_image</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sub_images</span>

<span class="k">class</span> <span class="nc">SubImage</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Store the current position of a sub_image </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        - image: an array, represent the sub image
        - y: int to represent the top coordinate in the parent image
        - x: int to represent the left coordinate in the parent image
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">SubImage</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sup_y0</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sup_x0</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">old_x_y</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> convert (y, x) in the subimage to the parent image coordinate system </span><span class="sh">"""</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">sup_y0</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">sup_x0</span><span class="p">)</span></code></pre></figure>

<p><strong>Convert from subimage to original image</strong></p>

<p>The process is a little tricky. Because the subimages are actually cropped from padded image, the coordinates of subimages in the coordinate of original image can be less than 0, and also bigger than the original image size (see following figure). So we should make sure the details right when convert subimage information (e.g. human face bounding box) to original image coordinates.
<img src="http://houxianxu.github.io/assets/images/CNNFace/1.png" alt="padded and subimage" title="padded and subimage" /></p>

<p>Following code illustrate how to convert a subimage heatmap to the corresponding position in the coordinates of the original image</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">pad_subheatmap_to_old_size</span><span class="p">(</span><span class="n">sub_heatmap_image</span><span class="p">,</span> <span class="n">sub_image</span><span class="p">,</span> <span class="n">padded_square</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Zero-pad sub_heatmap to the size of the old image size of which the sub_images cropped from </span><span class="sh">"""</span>
    <span class="n">padded_heatmap</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">padded_square</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sub_image_size</span> <span class="o">=</span> <span class="n">sub_heatmap_image</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">padded_square_size</span> <span class="o">=</span> <span class="n">padded_square</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># get coordinate in old/super image of the origin point in the heatmap 
</span>    <span class="n">y_start_old</span><span class="p">,</span> <span class="n">x_start_old</span> <span class="o">=</span> <span class="n">sub_image</span><span class="p">.</span><span class="nf">old_x_y</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">y_end_old</span><span class="p">,</span> <span class="n">x_end_old</span> <span class="o">=</span> <span class="n">y_start_old</span> <span class="o">+</span> <span class="n">sub_image_size</span><span class="p">,</span> <span class="n">x_start_old</span> <span class="o">+</span> <span class="n">sub_image_size</span>
    <span class="n">y_start_sub</span><span class="p">,</span> <span class="n">x_start_sub</span><span class="p">,</span> <span class="n">y_end_sub</span><span class="p">,</span> <span class="n">x_end_sub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sub_image_size</span><span class="p">,</span> <span class="n">sub_image_size</span>

    <span class="c1"># Here is a little tricky, please refer to image_misc.split_image
</span>    <span class="c1"># Note, there are two images. One is the cropped sub image and the old image which the subimage cropped from
</span>    <span class="k">if</span> <span class="n">y_start_old</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">y_start_sub</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">y_start_old</span>
        <span class="n">y_start_old</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">x_start_old</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x_start_sub</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">x_start_old</span>
        <span class="n">x_start_old</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">y_end_old</span> <span class="n">padded_square_size</span><span class="p">:</span>
        <span class="n">y_end_sub</span> <span class="o">=</span> <span class="n">sub_image_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">y_end_old</span> <span class="o">-</span> <span class="n">padded_square_size</span><span class="p">)</span>
        <span class="n">y_end_old</span> <span class="o">=</span> <span class="n">padded_square_size</span>

    <span class="k">if</span> <span class="n">x_end_old</span> <span class="n">padded_square_size</span><span class="p">:</span>
        <span class="n">x_end_sub</span> <span class="o">=</span> <span class="n">sub_image_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">x_end_old</span> <span class="o">-</span> <span class="n">padded_square_size</span><span class="p">)</span>
        <span class="n">x_end_old</span> <span class="o">=</span> <span class="n">padded_square_size</span>

    <span class="n">padded_heatmap</span><span class="p">[</span><span class="n">y_start_old</span><span class="p">:</span><span class="n">y_end_old</span><span class="p">,</span> <span class="n">x_start_old</span><span class="p">:</span><span class="n">x_end_old</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sub_heatmap_image</span><span class="p">[</span><span class="n">y_start_sub</span><span class="p">:</span><span class="n">y_end_sub</span><span class="p">,</span> <span class="n">x_start_sub</span><span class="p">:</span><span class="n">x_end_sub</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">padded_heatmap</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[My PhD work about object specific deep features for Face Detection]]></summary></entry><entry><title type="html">Interpretation of Matrix</title><link href="http://houxianxu.github.io/blog/2015/matrix-multiply-interpretation/" rel="alternate" type="text/html" title="Interpretation of Matrix" /><published>2015-05-18T00:00:00+00:00</published><updated>2015-05-18T00:00:00+00:00</updated><id>http://houxianxu.github.io/blog/2015/matrix-multiply-interpretation</id><content type="html" xml:base="http://houxianxu.github.io/blog/2015/matrix-multiply-interpretation/"><![CDATA[<p>When I study and implement machine learning algorithm, it is crucial and tricky to use matrix-matrix multiplication (which generalizes all matrix-vector and vector-vector) to speed up algorithms. However it is difficult to interpret the vectorized expressions, which needs strong linear algebra background. This post summarizes some basic concept in linear algebra and focuses more on the interpretation, which could be very helpful for us to understand some machine learning algorithms such as Neural Networks (just a chain of matrix-matrix multiplication).</p>

<h2 id="1-n-linear-equation-with-n-unknowns">1. N linear equation with n unknowns</h2>

<p>Example with N = 2 (2-dimension):
\(\begin{cases}2x - y = 0\\-x + 2y = 3\end{cases} = \begin{bmatrix}2 &amp; -1 \\-1 &amp; 2 \end{bmatrix} \begin{bmatrix}x \\y \end{bmatrix} = \begin{bmatrix}0 \\3 \end{bmatrix}\)</p>

<h4 id="row-picture">Row picture</h4>
<p>This is the way we often interpret the two equations above: just <strong>two line in 2-D space</strong>, and the solution is the point lies on both lines.</p>

<!-- ![Plot of Two equations](/assets/images/linearAlgbra/1.png "Row picture") -->
<center><img src="/assets/images/linearAlgbra/1.png" width="80%" /></center>

<h4 id="column-picture---linear-combination-of-columns">Column picture - linear combination of columns</h4>
<p>Follow the column we can rewrite the equations above as follows:</p>

\[x \begin{bmatrix}2 \\-1 \end{bmatrix}  + y \begin{bmatrix}-1 \\ 2 \end{bmatrix} = \begin{bmatrix}0 \\ 3 \end{bmatrix}\]

<p>We can interpret the above equation as <strong>linear combination of columns</strong> which are vectors in 2-D, and the <strong>+</strong> is overloaded for 2-D vector addition, as compared with scalar addition in row picture interpretation. The geometry is shown below.</p>

<!-- ![Plot of Two equations](/assets/images/linearAlgbra/2.png "column picture") -->
<center><img src="/assets/images/linearAlgbra/2.png" width="80%" /></center>

<p>When considering high dimension problem (say n = 10, i.e., 10 linear equation with n unknowns), it is not easy to imagine n-D space from Row Picture. However from Column Picture, the result is just the linear combination of 10 vectors.</p>

<h2 id="2-matrix-multiplication-as-linear-combination">2. Matrix multiplication as linear combination</h2>
<p>Usually we do matrix multiplication is to get the result cell as the dot product of a row in the first matrix with a column in the second matrix. However there is a very good interpretation from linear combination aspect, which is a core concept in linear algebra.</p>

<h4 id="21-linear-combination-of-columns-of-matrix">2.1 Linear combination of columns of matrix</h4>

\[\begin{bmatrix}1 &amp; 2 &amp; 3\\ 4&amp;5&amp;6\\7&amp;8&amp;9 \end{bmatrix} \begin{bmatrix}a \\b \\c\end{bmatrix} 
= a \begin{bmatrix}1 \\ 4\\7 \end{bmatrix} + b \begin{bmatrix}2 \\ 5\\8 \end{bmatrix} + c \begin{bmatrix}3 \\ 6\\9 \end{bmatrix} = \begin{bmatrix}1a + 2b + 3c \\ 4a + 5b+6c\\7a+8b+9c \end{bmatrix}\]

<p>Representing the columns of matrix by colorful boxes will help visualize this as follows: (the picture is from <a href="http://eli.thegreenplace.net/2015/visualizing-matrix-multiplication-as-a-linear-combination/">Eli Bendersky</a>)</p>

<!-- ![matrix-vector](/assets/images/linearAlgbra/3.png) -->
<center><img src="/assets/images/linearAlgbra/3.png" width="80%" /></center>

<p>For matrix multiply a column vector, the result is a column vector which is the linear combination of the columns of the matrix and the coefficients are the second vector. This idea can also be generalized to Matrix-Matrix multiplication, i.e., the columns of the result matrix is the first matrix multiply each column (vector) in the second matrix respectively. The following picture shows the idea.</p>

<!-- ![matrix-matrix](/assets/images/linearAlgbra/4.png "matrix-matrix") -->
<center><img src="/assets/images/linearAlgbra/4.png" width="80%" /></center>

<h4 id="22-linear-combination-of-rows-of-matrix">2.2 Linear combination of rows of matrix</h4>
<p>Similarly we can view the matrix as different rows. 
\(\begin{bmatrix}a &amp;b &amp;c\end{bmatrix}  \begin{bmatrix}1 &amp; 2 &amp; 3\\ 4&amp;5&amp;6\\7&amp;8&amp;9 \end{bmatrix} 
= a \begin{bmatrix}1 &amp; 2 &amp; 3 \end{bmatrix} + b \begin{bmatrix}4&amp;5&amp;6 \end{bmatrix} + c \begin{bmatrix}7&amp;8&amp;9 \end{bmatrix}\)
The above equation can be represented as follows:</p>

<!-- ![vector-matrix](/assets/images/linearAlgbra/5.png "vector-matrix") -->
<center><img src="/assets/images/linearAlgbra/5.png" width="80%" /></center>

<p>For matrix-matrix multiplication, the rows of the result matrix is each row (vector) in first matrix multiply the second matrix. The idea can be represented graphically following:</p>

<!-- ![matrix-matrix](/assets/images/linearAlgbra/6.png "matrix-matrix") -->
<center><img src="/assets/images/linearAlgbra/6.png" width="80%" /></center>

<h4 id="23-column-row-multiplication">2.3 Column-row multiplication</h4>

<p>There is another interpretation of matrix multiplication from \(column * row\) view.</p>

\[\begin{bmatrix}a \\ b \\ c \end{bmatrix} \begin{bmatrix}x &amp; y &amp; z \end{bmatrix} = \begin{bmatrix}ax&amp;ay&amp;az \\ bx&amp;by&amp;bz \\ cx&amp;cy&amp;cz \end{bmatrix}\]

<p>The above result is a 3 by 3 matrix. And if we two matrix are m by n and n by p, the shape of the result matrix is m by p and the result is the sum of all the matrix (m by p) computed by all the \(n^{th}\) column in the first matrix and \(n^{th}\) row in the second matrix.</p>

<h4 id="24-block-matrix-multiplication">2.4 Block matrix multiplication</h4>
<p>There is even another amazing interpretation of matrix multiplication. It is often convenient to partition a matrix <strong>A</strong> into smaller matrices called blocks. Then we can treat the blocks as matrix entries when do matrix multiplication.</p>

\[AB = \left[
\begin{array}{cc} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \end{array} \right]\cdot
\left[
\begin{array}{cc} b_{11} &amp; b_{12} \\ b_{21} &amp; b_{22} \end{array} \right]
= 
\left[
\begin{array}{cc} a_{11}b_{11}+a_{12}b_{21} &amp; a_{11}b_{12}+a_{12}b_{22} \\ a_{21}b_{11}+a_{22}b_{21} &amp; a_{22}b_{12}+a_{22}b_{22} \end{array} \right]\]

<p>which is equal to:</p>

\[AB = \left[
\begin{array}{c|c} A_{11} &amp; A_{12} \\\hline A_{21} &amp; A_{22} \end{array} \right]\cdot
\left[
\begin{array}{c|c} B_{11} &amp; B_{12} \\\hline B_{21} &amp; B_{22} \end{array} \right]
= 
\left[
\begin{array}{c|c} A_{11}B_{11}+A_{12}B_{21} &amp; A_{11}B_{12}+A_{12}B_{22} \\\hline A_{21}B_{11}+A_{22}B_{21} &amp; A_{22}B_{12}+A_{22}B_{22} \end{array} \right]\]

<h4 id="25-elimination-matrices">2.5 Elimination matrices</h4>

<p>The linear combination interpretation of matrix multiplication is very useful for us to understand matrix transformation. Especially when we do row operation, we can achieve elimination to solve a system of linear equations. Take the following matrix multiplication for example AX=B, we want to choose the first matrix <strong>A</strong> in order to transform matrix <strong>X</strong> to <strong>B</strong>.</p>

\[\begin{bmatrix}a &amp;b &amp;c \\ d&amp;e&amp;f \\ g&amp;h&amp;i \end{bmatrix} \begin{bmatrix}1 &amp; 2 &amp; 3\\ 4&amp;5&amp;6\\7&amp;8&amp;9 \end{bmatrix} = \begin{bmatrix}1 &amp; 2 &amp; 3\\ 0&amp;-3&amp;-6\\7&amp;8&amp;9 \end{bmatrix}\]

<p>Recall that the row in result matrix the row in <strong>A</strong> multiply <strong>X</strong>, which is the linear combination of rows of <strong>X</strong>. Because the first and third row is the same, so the first and third row in A should be \([1 \: 0 \: 0]\) and \([0 \: 0 \: 1]\) and the second row in <strong>B</strong> is the second row minus 4 times first row in <strong>A</strong>, i.e., \([row2 - 4*row1]\). So the second row in <strong>A</strong> should be \([-4 \: 1 \: 0]\). Put all together A = \(\begin{bmatrix}1 &amp; 0 &amp; 0\\ -4&amp;1&amp;0\\0&amp;0&amp;1 \end{bmatrix}\)</p>

<h4 id="26-permutation-of-matrix">2.6 Permutation of matrix</h4>
<p>Exchange the two rows in a matrix <strong>A</strong>, we just need to multiply some matrix on the left as shown as follows. For example in the result matrix, the first row is the linear combination of the rows in the second matrix with respect to first row in the first matrix. What we want is the second row, so the second cell in the first matrix should be 1, and first cell should be 0, which has no contribution to the first row in the result matrix.</p>

\[\begin{bmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix}a &amp; b \\ c &amp; d \end{bmatrix} = \begin{bmatrix}c &amp; d \\ a &amp; b \end{bmatrix}\]

<p>If want to exchange the columns, we just need to do column operation:</p>

\[\begin{bmatrix}a &amp; b \\ c &amp; d \end{bmatrix} \begin{bmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  = \begin{bmatrix}b &amp; a \\ d &amp; c \end{bmatrix}\]

<p><strong>In short, if we want to do column operations the matrix multiplies on the right, and to do row operations, it multiplies on the left.</strong></p>

<p>##3 Inverse or non-singular matrix
Suppose <strong>A</strong> is square matrix, and if \(A A^{-1} = I\) (\(I\) is identity matrix), then matrix A is invertible and the inverse matrix is \(A^{-1}\). We can see whether inverse matrix is a property for a given matrix, and not all matrices have inverse matrix. One simple way to determine whether you can find a vector <strong>x</strong> != <strong>0</strong> with <strong>Ax = b</strong>, and if you cannot find a <strong>x</strong>, then A has inverse matrix, otherwise not. For example,</p>

\[\begin{bmatrix}1 &amp; 3 \\ 2 &amp; 6 \end{bmatrix} \begin{bmatrix}3  \\ -1 \end{bmatrix} = \begin{bmatrix}0\\0 \end{bmatrix}\]

<p>There couldn’t be an inverse for the first matrix above. We can think that the first and second column (vector) are in same direction, the linear combination of them can not be <strong>0</strong>.</p>

<p>If matrix A does has inverse matrix, then Guass-Jordan elimination can solve it: \(E[A I] = [I A^{-1}]\), where \(EA = I\). You interpret the equation as block matrix multiplication. We can use inverse matrix to factorize matrix as two matrix multiplication. First use elimination (or elemental) matrix <strong>E</strong> to transform <strong>A</strong> into <strong>U</strong>, i.e. \(EA = U\), then solve A as \(A = E^{-1}U = LU\). The factors <strong>L</strong> and <strong>U</strong> are triangular matrices. Because of <strong>U</strong> is the result of elimination, so it should be a upper triangular matrix. For <strong>L</strong>, we can use Guass-Jordan elimination \(E[A I] = [I A^{-1}]\) to compute the <strong>L</strong>, because the we just do elimination of <strong>I</strong> with <strong>E</strong>, so the cell values in the upper bound are all zero, so <strong>L</strong> is a lower triangular matrix. If we need to exchange rows, all we need is to multiply a permutation matrix on the left: \(PA = E^{-1}U = LU\).</p>

<p>Another property of invertible square matrix is that you can exchange transposing and inversing for a singular matrix. \((A^{-1})^T \: A^T = I\), i.e., \((A^{-1})^T = (A^T)^{-1}\). More more interesting thing is that when a matrix multiply its transpose, we get a symmetry matrix. \((A A^{T})^T = (A^T)^T A^T = AA^T\).</p>

<h2 id="3-vector-spaces">3. Vector Spaces</h2>
<p>Vector space means the “space” of vectors, which should satisfy some rules, i.e., we can multiply any vector v by any scalar c in that space, that’s to say they can produce <strong>linear combination</strong>. For example, \(\mathbb{R}^2\) space contains all the real vectors with 2 components and it represents x-y plane, and \(\mathbb{R}^2\) space contains all the real vectors with 2 components and it represents x-y plane, and \(\mathbb{R}^3\) space contains all the real vectors with 3 components and it represents x-y-z 3-d space.</p>

<p>Subspace is a vector space which contains some or all the vectors from another vector space. Subspace should be satisfy the definition of space (linear combination) and it is based on another vector space. For instance, there are 4 subspace of \(\mathbb{R}^3\): <strong>Z</strong> – the single vector (0 0, 0); (<strong>L</strong>) – any line through (0, 0, 0); (<strong>P</strong>) – any plane through(0, 0, 0); \(\mathbb{R}^3\) – the whole space.</p>

<p>In return, we can use some vectors or a matrix to construct vector space because all we need is linear combination. Given a matrix, the linear combination of all the columns of matrix from a space, which is called <strong>column space</strong>. For example:</p>

\[A = \begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4 \\ 5&amp;6 \end{bmatrix}\]

<p>The column vector of A is in \(mathbb{R}^3\), and all the combinations of columns form a subspace, which is plane through origin. And the intersection of two subspace is a subspace.</p>

<p>##4. Interpret \(Ax=b\) with vector space
 #### column space
We can interpret \(Ax\) (<strong>A</strong> is a matrix and <strong>x</strong> is a vector) as linear combination of columns of matrix using vector x, i.e., which is the columns space define by matrix A. So we can view \(Ax=b\) as finding the perfect linear combination of the columns to make it equal to vector <strong>b</strong>, and the vector <strong>b</strong> should be in the column space defined by matrix <strong>A</strong>.</p>

\[Ax = \begin{bmatrix}1 &amp; 5 &amp;6\\ 2 &amp; 6 &amp; 8\\ 3&amp;7&amp;10 \\4&amp;8&amp;12 \end{bmatrix} \begin{bmatrix}x \\ y \\ z \end{bmatrix} = b\]

<p>Take above equation for example, not for all b we can find a solution. Because <strong>b</strong> could be any vector in \(\mathbb{R}^4\) and the left hand side the combinations of 3 columns don’t fill the whole 4-D space. The fact is that there are a lot of vectors b are not the combinations of the 3 columns (column subspace which is inside \(\\mathbb{R}^4\)). We can only solve the equation when <strong>b</strong> is in the column space of <strong>A</strong>, for example, \(x = [1 \: 0 \: 0]^T\), when \(b = [1 \: 2 \: 3 \: 4]^T\).</p>

<h4 id="null-space">Null space</h4>
<p>Particularly for equation \(Ax=b=0\), we can get a bunch of vectors <strong>x</strong> as the solutions and this vectors can compose a subspace because \(A(v + w) = Av + Aw = 0\). Take example above (when b = 0), the solution is \(c[1\:1\:-1]^T\) (c is constant), which is called <strong>Null space</strong>. And if \(b != 0\), then the solution is not a subspace because <strong>0</strong> is not in that bunch of vectors.</p>

<h2 id="5-compute-ax--b">5. Compute \(Ax = b\)</h2>
<h4 id="null-space-b--0">Null space b = 0</h4>
<p>We can do elimination for matrix A and get the matrix <strong>U</strong>, and then continue simplifying the <strong>U</strong> to get matrix <strong>R</strong> which is reduced row echelon form and <strong>R</strong> has the form of</p>

\[\begin{bmatrix}I&amp;F\\ O&amp;O\\\end{bmatrix}\]

<p>\(I\) is identity matrix and indicates pivot variables. In fact the particular solutions are the columns of matrix
\(N = {\begin{bmatrix}-F &amp;I\end{bmatrix}}^T\), the null space is the column space of N. This is because of following matrix block multiplication.</p>

\[\begin{bmatrix}I&amp;F\\ O&amp;O\\\end{bmatrix} {\begin{bmatrix}-F \\ I\end{bmatrix}} = O\]

<h4 id="b--0">b != 0</h4>
<p>First we should consider whether the equation has solution or not, as mentioned above, <strong>Ax = b</strong> is solvable when b is column space of A, i.e., C(A). On the other hand, after finishing the elimination step, if the a combination of rows of A gives zero rows, the same combination of entries of b must give 0.</p>

<p>If the equation does have solutions, we can use elimination to find a particular solution. As long as we get one particular solution, the complete solution is the particular solution plus the any vector in the null space of <strong>A</strong>. that’s to say, \(x = x_{particular} + x_{null}\). The shape of the complete solution is similar to Null space, we can interpret the complete space as null space which is shifted by vector \(x_{particular}\). This is because:</p>

\[Ax_p = b \: \: and \:\:Ax_n = 0 \:\:= \: A(x_p + x_b) = b\]

<h4 id="solution-discussion--m-by-n-matrix-a-of-rank-r">Solution discussion – m by n matrix A of rank r</h4>
<p><strong>Full column rank, i.e., r = n</strong></p>

<ol>
  <li>There are free variables</li>
  <li>The null space is {<strong>0</strong>}</li>
  <li>Unique solution if it exists (0 or 1 solution)</li>
  <li>The reduced row echelon form is \(\begin{bmatrix}I\\ O\\\end{bmatrix}\).</li>
</ol>

<p><strong>Full row rank, i.e., r = m</strong></p>

<ol>
  <li>It can be solved Ax=b for every b, because every row have a pivot and no zero rows.</li>
  <li>There are n - r free variables and there are infinite solutions.</li>
  <li>The reduced row echelon form is \(\begin{bmatrix}I&amp;F\end{bmatrix}\)</li>
</ol>

<p><strong>Full column and row rank, i.e., r = m = n</strong></p>

<ol>
  <li>Invertible matrix of A</li>
  <li>Unique solution</li>
  <li>The reduced row echelon form is identity <strong>I</strong>.</li>
</ol>

<p><strong>Not full rank, i.e., r &lt; m, and r &lt; n</strong></p>

<ol>
  <li>There are no solutions or infinite solutions</li>
  <li>The reduced row echelon form is \(\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}\)</li>
</ol>

<h2 id="6-independent-span-basis-dimension">6. Independent, span, basis dimension</h2>
<p>Independent is used to describe the relation between vectors. Vectors \(v_1, v_2, ..., v_n\) are Independent if no linear combination gives zero vector (except the zero combination), i.e., \(c_1 v_1 + c_2 v_2 + ... + c_n v_n != 0\). From vector space point of view, \(v_1, v_2, ..., v_n\) are columns of matrix <strong>A</strong>, they are independent if null space of A is zero vector and the rank r = n with no free variables, and they are independent if Ac = 0 for some non-zero vector c and rank &lt; n with free variables.</p>

<p>Vectors \(v_1, v_2, ..., v_n\) <strong>span</strong> a vector space means that the space contains all the linear combination of those vectors. They vectors could be independent or dependent.</p>

<p>We are more interested in the vectors spanning a space are independent, which means the right number or minimal number of vectors to span a given space and we use <strong>basis</strong> to indicate this idea. Basis for a vector space is segment of vectors with 2 properties: (1) They are independent; (2)They span a space.</p>

<p>For a given space such as \(\mathbb{R}^4\), every basis has the same number of vectors and the number is called <strong>dimension of the space</strong>. So when putting all together, we get the conclusion the rank of a matrix <strong>A</strong> == the number of pivot columns == dimension of the column space.</p>

<h2 id="7-orthogonal">7. Orthogonal</h2>
<p>Vector x is orthogonal to vector y, when \(x^T y = 0\)
Subspace S is orthogonal to subspace T means: every vector in S is orthogonal to every vector in T. For every space, the row space is orthogonal to nullspace. Because of Ax = 0, so the linear combination of rows respecting to null space is 0, i.e. \(\sum_i^m c_i \: row_i = 0\)
Moreover, nullspace and row space are orthogonal complements in \(R^n\) and nullspace contains all vectors perpendicular to the row space.</p>

<h2 id="8-solve-ax--b-when-there-are-no-solutions">8. “Solve” \(Ax = b\) when there are no solutions</h2>
<p>We know that \(Ax = b\) is only solvable when vector <strong>b</strong> is in the column space of A. In practice, this equation is often unsolvable when A is a rectangular. Take m by n matrix (m  n)for example, there are more constrains or equations than unknown variables and there may be no solutions when some equations conflict each other. In other words, there is a lot of information about x here. One naive method is only using some of information (equations), however, there is no reason to say some equations are perfect and some are useless and we want to use all the information to get the best solution.</p>

<p>When \(Ax = b\) cannot be solved perfectly, what can we do? And can we do better? The reason that the equation is not solvable is because <strong>b</strong> is not in the column space of <strong>A</strong>, so we may be able to find a “closest” vector (say <strong>p</strong>) to replace <strong>b</strong> in the column space of <strong>A</strong>, i.e., \(A\hat{x} = p\), and use \(\hat{x}\) to estimate \(x\). The next problem is to define the “best” <strong>p</strong>, and the projection of <strong>b</strong> onto column space <strong>A</strong> is used instead. And then we need to find a way to calculate the projected vector <strong>p</strong> from <strong>b</strong>.</p>

<!-- ![projection from vector to vector](/assets/images/linearAlgbra/7.png) -->
<p><img src="/assets/images/linearAlgbra/7.png" width="100%" /></p>

<p>For simplicity, we first consider projection from vector to vector (see the left diagram above). We use <strong>p</strong> to indicate the projection of <strong>b</strong> onto <strong>a</strong> and <strong>b</strong> is equal to some multiple of <strong>a</strong>, i.e., \(xa\). According to is perpendicular to e, we have:</p>

\[a^T e = a^T (b-xa) = a^Tb - xa^Ta = 0 \: = \: x = \frac{a^Tb}{a^Ta} \\
So \: p = xa = \frac{a^Tb}{a^Ta} a \\
We \: can \: rewrite \: as \: p = P b = \big(\frac{a a^T}{a^T a}\big) b\]

<p>Notice that <strong>P</strong> is a n by n matrix if vector b and a have n elements and it is determined only by the vector <strong>a</strong> which we want to project onto. P is called projection matrix and we can interpret it as a <strong>function</strong> coming from vector <strong>a</strong> to project another vector to itself. Additionally we can observe that \(P^T = (\frac{a a^T}{a^T a})^T = P\) and \(PP = \frac{a a^T}{a^T a} \frac{a a^T}{a^T a} = \frac{a (a^T a) a^T} {(a^T a) (a^T a)} = P\)</p>

<p>Next we consider projection from vector to space (see the right diagram above), the plane is the column space of A = [a1 a2], the error <strong>e = b - p</strong> and it is perpendicular to <strong>A</strong>. The projection <strong>b</strong> to <strong>A</strong> is \(a_1 x_1 + x_2 x_2 = A x\) and our aim is to find <strong>x</strong>. Because <strong>e = b - Ax</strong> is perpendicular to the plane:</p>

\[\begin{cases}a_1^T(b-Ax) = 0\\a_2^T(b-Ax) = 0\end{cases} \: = \begin{bmatrix}a_1^T \\a_2^T\end{bmatrix} \begin{bmatrix}b-Ax\end{bmatrix} = \begin{bmatrix}0 \\0\end{bmatrix} = A^T \begin{bmatrix}b-Ax\end{bmatrix} = 0 \\ = A^Tb - A^TA x = 0 \: = x = (A^TA)^{-1} A^T b \\ = p = A x = A (A^TA)^{-1} A^T b = P b\]

<p>From above equation we can interpret the (b-Ax) is in the null space of \(A^T\), and the (b-Ax) should be perpendicular to the row space of \(A^T\) which is the column space of A, which is the plane defined by <strong>a</strong> and <strong>b</strong>.
The matrix \(P = A(A^TA){-1} A^T\) is called projection matrix, which can also be interpreted as a function to project a vector b onto the column space of <strong>A</strong>. Moreover \(P^T = P\) and \(PP = P\). Here if A has independent columns then \(A^TA\) is invertible. Here is a simple proof: suppose \(A^TAx=0\), then x must be 0 if \(A^TA\) is invertible.</p>

\[A^TAx=0 \:= x^TA^TAx =0\:=(Ax)^T(Ax) = 0\:=Ax = 0=x=0\]

<h2 id="9-determinant">9. Determinant</h2>
<p>The square matrix is relatively easy to deal with, and the determinant is a number that associates with a square matrix, \(det\: A=\|A\|\). Though this number can’t not tell you all the information of the matrix, it can tell you a lot of information. Following is some important properties of determinant.</p>

<ul>
  <li>Determinant of <strong>I</strong> is 1</li>
  <li>Exchange two rows of a matrix: reverse sign of determinant.</li>
  <li>Linear combination of one row, and det (A+B) != det(A) + det(B)</li>
</ul>

\[\begin{vmatrix}ta &amp;tb \\c &amp;d \end{vmatrix} = t\begin{vmatrix}a &amp;b \\c &amp;d \end{vmatrix}\:\:\:\: and \:\:\: \: \begin{vmatrix}a + a'&amp;b'+b \\c &amp;d \end{vmatrix} = \begin{vmatrix}a &amp;b \\c &amp;d \end{vmatrix} + \begin{vmatrix}a' &amp;b' \\c &amp;d \end{vmatrix}\]

<ul>
  <li>Two equal rows, then determinant is 0. We can get it by exchanging the same row.</li>
  <li>Subtract l * row i from row k, and the determinant doesn’t change, i.e. elimination process.</li>
</ul>

\[\begin{vmatrix}a &amp;b \\c-la &amp;d-lb \end{vmatrix} = \begin{vmatrix}a &amp;b \\c &amp;d \end{vmatrix} -l \begin{vmatrix}a &amp;b \\a &amp;b \end{vmatrix} = \begin{vmatrix}a &amp;b \\c-la &amp;d-lb \end{vmatrix}\]

<ul>
  <li>Row of zeros, the determinant is equal to 0</li>
  <li>Triangular matrix, the determinant is product of pivots, which is based on property 3.</li>
  <li>det A = 0, when A is singular, and det A != 0 when A is invertible.</li>
  <li>det(AB) = det(A)*det(B), and \(det(A^{-1}) = \frac{1}{det(A)}\)</li>
  <li>
\[det(A^T) = det(A) \:\: |A^T| = |A| &lt;= |U^TL^T| = |LU| &lt;= |U^T||L^T| = |L||U|\]
  </li>
</ul>

<p>Cofactor of one entry
Cofactor of \(a_{ij} = c_ij\) is the (+/-) determinant of n-1 matrix with row i and column j erased, when i+j is even choose +, and choose - when i+j is odd. 
Cofactor formula is: \(det(A) = a_{i1}c_{i1} + a_{i2}c_{i2} + ... + a_{in}c_{in}\)</p>

<p>Another very good interpretation is that the determinant is the <strong>volume</strong> of a box determined by row vectors.</p>

<h2 id="10-eigenvalue-and-eigenvector">10. Eigenvalue and eigenvector</h2>
<p>The result vector \(Ax\) is parallel to x, and the vector <strong>x</strong> is called eigenvector of square matrix A, i.e.,</p>

\[Ax = \lambda x\]

<p>The \(\lambda\) is called eigenvalue.</p>

\[Ax = \lambda x \:\: = \:\: (A - \lambda I) x = 0\]

<p>Notice that \((A - \lambda I)\) should be singular, otherwise x must be 0. So the det\((A - \lambda I)\) = 0, and after finding the eigenvalues we can find the eigenvectors by computing null space. For most n by n matrix, there are n eigenvectors and eigenvalues. Some matrix just has one eigenvectors and eigenvalues of some matrix are complex number.</p>

<p>Above we know how to compute the eigenvalues and eigenvectors, then how to use them. Suppose there are n independent eigenvectors of n by n matrix A, and put them in column matrix S.</p>

\[AS = A[x_1, x_2, ..., x_n] = [\lambda_1x_1, \lambda_2x_2, ..., \lambda_nx_n] = [x_1, x_2, ..., x_n] \begin{bmatrix}\lambda_1&amp;0&amp;\cdots&amp;0\\
0&amp;\lambda_2&amp;\cdots&amp;0\\
0&amp;0&amp;\ddots&amp;0\\
0&amp;0&amp;\cdots&amp;\lambda_n\end{bmatrix} = S\Lambda\]

<p>\(\Lambda\) is called diagonal eigenvalue matrix</p>

\[AS = S\Lambda \:\: = \:\: S^{-1} AS = \Lambda \:\: =\:\: A = S\Lambda S^{-1}\]

<p>In fact, the eigenvectors and eigenvectors give a way what is going on inside a matrix and to understand the power of matrix. For example, \(A^k - 0 \:\:as\:\: k - \infty\) if all \(\|\lambda_i\| &lt; 1\).</p>

\[Ax = \lambda x \:\: =\:\: A^2 x = \lambda Ax = {\lambda}^2 x \\
A^2 = S \Lambda S^{-1} S \Lambda S^{-1} = S {\Lambda}^2 S^{-1} \\
A^k = S {\Lambda}^k S^{-1}\]

<p>Base on the above equation, A is sure to have n independent eigenvectors and can be diagonalizable if all the eigenvalues \(\lambda_i\) are different.</p>

<p>We can use eigenvectors to solve following problem: \(u_{k+1} = Au_k\), start with a give vector \(u_0\), and we can see \(u_k = A^k u_0\).
To really solve above equation, we can first write \(u_0\) as the linear combination of eigenvectors of matrix A. Then:</p>

\[u_0 = c_1 x_1 + c_2 x_2 + ... + c_n x_n\\
= A u_0 = A(c_1 x_1 + c_2 x_2 + ... + c_n x_n) = c_1 \lambda_1 x_1 + c_2 \lambda_2 x_2 + ... + c_n \lambda_n x_n\\
= A^2 u_0 = A A u_0 = A (c_1 \lambda_1 x_1 + c_2 \lambda_2 x_2 + ... + c_n \lambda_n x_n) = c_1 {\lambda_1}^2 x_1 + c_2 {\lambda_2}^2 x_2 + ... + c_n {\lambda_n}^2 x_n\\
=A^k u_0 = c_1 {\lambda_1}^k x_1 + c_2 {\lambda_2}^k x_2 + ... + c_n {\lambda_n}^k x_n = S \Lambda c\]

<p>Using above idea to solve Fibonacci problem, [0, 1, 1, 2, 3, 5, 8, 13, …], then how to get \(F_100\). So we need to find how fast the sequence grows, which lies in the eigenvalues.</p>

<p>We want the form \(u_{k+1} = A u_k\) to use the matrix A. And we can construct the matrix as follows</p>

\[\begin{cases}F_{k+2} = F_{k+1} + F_k\\F_{k+1} = F_{k+1}\end{cases} \:= \: u_{k+1} = Au_k = \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}u_k \:\: and \:\: u_{k} = \begin{bmatrix}F_{k+1}\\F_k\end{bmatrix}\\\\
A = \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix} \:=\: |A-\lambda I| = {\lambda}^2 - \lambda - 1 = \lambda_1 =  \frac{1+\sqrt{5}}{2} \approx 1.618 \:\: \lambda_2 = \frac{1-\sqrt{5}}{2}  \approx  -0.618 \\
Eigenvectors \: are \: x_1 = [\lambda_1\:1]^T, \: x_2 = [\lambda_2 \:1]^T
u_0 = [1\: 0]^T = c_1 x_1 + c_2 x_2 \:=\: c_1 = 0.447 \: c_2 = -0.447\\
u_{100} = A^{100} u_0 = c_1 {\lambda_1}^{100} x_1 + c_2 {\lambda_2}^{100} x_2 = 0.447 (1.618)^{100} [1.618\:1]^T - 0.477 (-0.618)^{100} [-0.618\:1] \\
u_{100} \approx 0.447 (1.618)^{100} [1.618\:1]^T\]

<h2 id="11-first-order-differential-equation-d_u--d_t--au">11. First order differential equation \(d_u / d_t = Au\)</h2>
<p>We also arrange two or more equation into matrix form and try to solve it from matrix aspect. For example:</p>

\[\begin{cases}\frac{du_1}{dt} = -u_1 + 2u_2\\\frac{du_2}{dt} = u_1-2u_2\end{cases} \:=\: \frac{du}{dt} = A\begin{bmatrix}u1\\u2\end{bmatrix} = \begin{bmatrix}-1 &amp;2\\1&amp;-2\end{bmatrix} \begin{bmatrix}u1\\u2\end{bmatrix}\]

<p>We can see from the above equation, u2 and u1 can be affected by each other and the relationship or all information, in fact, is the matrix A. So we maybe solve the differential equations as a single system. Usually this system is called Linear Dynamic System.</p>

<p>We can use eigenvectors and eigenvalues of matrix A to solve above system. The result is very simple \(u(t) = e^{tA}u(0)\). The key point is the matrix exponential, which can be interpreted by Taylor Series.</p>

\[\begin{equation}
     \begin{split} 
e^{At} &amp;= I + At + \frac{(At)^2}{2!} + \frac{(At)^3}{3!} + ... + \frac{(At)^n}{n!} + ... \\ 
&amp;= SIS^{-1} + S \Lambda S^{-1} t + \frac{S {\Lambda}^2 S^{-1} t}{2!} + \frac{S {\Lambda}^n S^{-1} t}{n!} + ... \\
&amp;= S(I + \Lambda t + \frac{ {\Lambda}^2 t}{2!} + \frac{ {\Lambda}^n t}{n!} + ...)S^{-1} \\
&amp;= Se^{\Lambda t}S{-1}
	\end{split}
    \end{equation}\]

<p>In the above equation, the S and \(\Lambda\) are defined by eigenvectors and eigenvalues. Notice that the equation should based on the fact that there are n independent eigenvectors of matrix A, i.e., A can be diagonalized. Moreover the \(e^{\Lambda t}\) can be easily computed as follows:</p>

\[\begin{equation}
     \begin{split}
e^{\Lambda t} 
&amp;= I + \Lambda t + \frac{ {\Lambda}^2 t}{2!} + \frac{ {\Lambda}^n t}{n!} + ... \\
&amp;= I + {\begin{bmatrix}\lambda_1&amp;0&amp;\cdots&amp;0\\
0&amp;\lambda_2&amp;\cdots&amp;0\\
0&amp;0&amp;\ddots&amp;0\\
0&amp;0&amp;\cdots&amp;\lambda_n\end{bmatrix}}^1 + ... + \frac{1}{n!}{\begin{bmatrix}\lambda_1&amp;0&amp;\cdots&amp;0\\
0&amp;\lambda_2&amp;\cdots&amp;0\\
0&amp;0&amp;\ddots&amp;0\\
0&amp;0&amp;\cdots&amp;\lambda_n\end{bmatrix}}^n + ...\\
&amp;= \begin{bmatrix}e^{\lambda_1 t}&amp;0&amp;\cdots&amp;0\\
0&amp;e^{\lambda_2 t}&amp;\cdots&amp;0\\
0&amp;0&amp;\ddots&amp;0\\
0&amp;0&amp;\cdots&amp;e^{\lambda_n t}\end{bmatrix} \\
\end{split}
    \end{equation}\]

<h2 id="12-symmetric-matrix-and-positive-definite">12. Symmetric matrix and positive definite</h2>
<p>Symmetric matrix is very special matrix and they are <strong>good</strong> matrices: the eigenvalues are REAL and eigenvectors can be chosen PERPENDICULAR. For usual case \(A = S \Lambda S^{-1}\), for symmetric matrix \(A = Q \Lambda Q^{-1} = Q \Lambda Q^T\), and the matrix Q is the orthonormal eigenvectors matrix.</p>

<p>In additional, \(A = Q \Lambda Q^T = \sum_i^n \lambda_i q_i {q_i}^T\), so every symmetric matrix is a combination of perpendicular projection matrices. This is because \(q_i {q_i}^T = \frac{q_i {q_i}^T}{q_i^T q_i}\), which is projection matrices.</p>

<p>Then how about the sign of \(\lambda_i\), and the eigenvalues decides between instability and stability in differential equations.
<strong>Positive definite</strong> means that all the eigenvalues are positive. Positive semidefinite is called when eigenvectors are greater or equal to zero. Formally the Positive definite of matrix A is defined as the quadratic form is greater that zero, i.e., \(x^TAx  0\)</p>

\[x^TAx = \begin{bmatrix}x &amp;y\end{bmatrix} \begin{bmatrix}a &amp;b \\ c &amp;d\end{bmatrix} \begin{bmatrix}x \\y\end{bmatrix} = ax^2 + (b+c)xy + dy^2\]

<p>Another fact is that the signs of pivots are the same as signs of \(\lambda_i\) and the number of positive pivot is equal to the number of positive eigenvalues.</p>

<p>We can interpret the quadratic form \(x^TAx = 1\) as tiled ellipse associated with symmetric matrix A.  \(X^T \Lambda X = 1\) is a lined-up ellipse associated with eigenvalues matrix \(Lambda\), and we can use eigenvectors matrix Q to rotate the tiled ellipse to lined-up ellipse. Here is an example:</p>

\[5x^2 + 8xy + 5y^2 = 1 \: =\: \begin{bmatrix}x&amp; y\end{bmatrix}A \begin{bmatrix}x\\y\end{bmatrix} = \begin{bmatrix}x&amp; y\end{bmatrix} \begin{bmatrix}5 &amp; 4\\4 &amp; 5\end{bmatrix} \begin{bmatrix}x\\y\end{bmatrix}\]

<p>Use eigenvectors and eigenvalues to diagonalized \(A = Q \Lambda Q^T\)</p>

\[\begin{bmatrix}5 &amp; 4\\4 &amp; 5\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}1 &amp; 1\\ 1&amp; -1\end{bmatrix} \begin{bmatrix}9 &amp; 0\\0 &amp; 1\end{bmatrix} \frac{1}{\sqrt{2}} \begin{bmatrix}1 &amp; 1\\1 &amp; -1\end{bmatrix}\]

<p>So \(5x^2 + 8xy + 5y^2 =9(\frac{x+y}{\sqrt{2}})^2 + 1(\frac{x-y}{\sqrt{2}})^2 = 9X^2 + 1(Y)^2 = 1\). We can see that the axes of the titled ellipse point are along the eigenvectors and the axis lengths are determined by eigenvalues, i.e. \(\frac{1}{\sqrt{\lambda_i}}\)</p>

<p>So in the xy system, the axes are along he eigenvectors of A. In the XY system, the axes are along the eigenvectors of \(\Lambda\). So if \(A=Q \Lambda Q^T\) is positive definite, i.e., \(\Lambda_i  0\). The graph \(x^TAx =1\) is an ellipse:</p>

\[\begin{bmatrix}x&amp; y\end{bmatrix} Q \Lambda Q^T \begin{bmatrix}x\\y\end{bmatrix} = \begin{bmatrix}X&amp; Y\end{bmatrix} \Lambda \begin{bmatrix}X\\Y\end{bmatrix} = \lambda_1 X^2 + \lambda_2 Y^2 = 1.\]

<p>\(A=Q \Lambda Q^T\) is called the <strong>principal axis theorem</strong>, which can help displays the axes, or rotate to a lined-up position.</p>

<h2 id="singular-value-decomposition-svd">Singular value decomposition (SVD)</h2>
<p>For a full rank square matrix, we can diagonalize the matrix as \(S^{-1}AS\). However, if A is any m by n matrix with rank r, can we still diagonalize it?</p>

<p>Based on the symmetric matrix, suppose A can be diagonalized as \(A = U \Sigma V^T\), U and V are orthonormal matrix, \(\Sigma\) is a diagonal matrix. The idea in fact is very simple, that’s we make A to be symmetric matrix.</p>

\[A^TA = V \Sigma^T U^T U \Sigma V^T = V \Sigma^2 V^T = Q_1 \Lambda Q_1^T\\
AA^T = U \Sigma V^T V \Sigma^T U^T = U \Sigma^2 U^T = Q_2 \Lambda Q_2^T\]

<p>Because \(A^TA\) and \(AA^T\) are symmetric matrix, we easily get V, U and \(\Sigma\). In details, \(v_1, ... v_r\) are orthonormal singular vectors in row space of A, the \(u_1, ..., u_r\) are orthonormal simple vectors in column space. We need n-r more v’s and m-r u’s from the null space N(A) and left null space \(N(A^T)\), \(Vv_n=0v_m\), and we set \(\sigma_i =0\) when i  r.</p>

\[A[v_1, ..., v_r, ..., v_n] = [u_1, ... ,u_r, ..., u_m] \begin{bmatrix}\sigma_1&amp;0&amp;\cdots&amp;0\\
0&amp;\sigma_r&amp;\cdots&amp;0\\
0&amp;0&amp;\ddots&amp;0\\
0&amp;0&amp;\cdots&amp;0\end{bmatrix}\]

<h2 id="9-reference-and-further-reading">9. Reference and further reading</h2>
<ul>
  <li><a href="http://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/">Introduction to Linear Algebra from MIT OpenCourseWare</a></li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[This the notes after learning linear algebra]]></summary></entry><entry><title type="html">Support Vector Machine</title><link href="http://houxianxu.github.io/blog/2015/support-vector-machine/" rel="alternate" type="text/html" title="Support Vector Machine" /><published>2015-04-25T00:00:00+00:00</published><updated>2015-04-25T00:00:00+00:00</updated><id>http://houxianxu.github.io/blog/2015/support-vector-machine</id><content type="html" xml:base="http://houxianxu.github.io/blog/2015/support-vector-machine/"><![CDATA[<p>Support vector machine (SVM) is often considered one of the best “out of the box” classifiers, and in this post I try to explain how we can come up with this algorithm from scratch.</p>

<p>I also implement the SMV for image classification with <a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10 dataset</a> by Python (numpy). <a href="http://houxianxu.github.io/implementation/SVM.html">This</a> is for mutli-classification by using SVM loss.</p>

<h2 id="1-problem-setting">1. Problem setting</h2>
<p>Classification problem is to classify different objects into different categories. For simplicity, we just focus on <strong>binary classification</strong> that y can take two values 1 or -1 (indicating two classes), and we firstly assume the two classes are linearly separable. After all, it is reasonable to solve problems from simple to complex.</p>

<h2 id="2-basic-idea-what-we-have-known">2. Basic idea (What we have known)</h2>
<p>If the data is linearly separable, our goal is to find the such a line \(f(x) = w^Tx + b = 0\) (2-dimension) that divides the plane into 2 parts and each part represent one class (see following figure). If the data is represented in high dimension say N-dimension, what we need to do is to find a hyperplane \(w^Tx + b = 0\) which is subspace with dimension (N-1)dimension. So if \(w^Tx + b = 0\), the label \(y = 1\), otherwise \(y = -1\). However, the problem is that in fact there exists infinite such hyperplanes if the data can be perfectly linearly separated, because a given separating hyperplane can be shifted a tiny bit up or down, or rotated without coming into contact with any of the observations (the line 1, 2 and 3 in the following figure) . Of course we can randomly choose a separating line.</p>

<!-- ![Scatter Plot of Two variables](http://houxianxu.github.io/assets/images/SVM/1.png "linearly separable") -->
<center><img src="/assets/images/SVM/1.png" width="80%" /></center>

<h2 id="3-maximal-margin-classifier">3. Maximal Margin Classifier</h2>
<p><strong>Can we do better?</strong></p>

<p>Is that possible for us to choose the even “best” line or hyperplane from the infinit possible separating hyperplanes? So the next question is how to define the “best” hyperplane. Because the final goal is trying to use the hyperplane as decision boundary to distinguish the two classes, so we can choose the hyperplane which can make the distinction more obvious. Intuitively the separating hyperplane should be farthest from the training observations, that’s to say, the distance between the nearest observation and the hyperplane should be maximized. This distance is usually called margin and the corresponding classifier is known as maximal margin classifier, and the separating hyperplane has the farthest minimum distance to the training observations. Take the above figure for example, line 3 is better than line 1 and 2.</p>

<p>From figure below, we can see that there are 3 training points having equal distance from the maximal margin line and the two dash lines indicate the width of margin. These 3 observations are known as <strong>support vectors</strong>. Since these points can interpreted as n-1 dimension vectors and define the maximal margin, in other words, these vectors can “support” the maximal margin hyperplane in the sense that if these points were moved slightly then the maximal margin hyperplane would move as well. What’s more, the maximal margin hyperplane is only depends on the support vectors, not other observation.</p>

<!-- ![Support Vector](http://houxianxu.github.io/assets/images/SVM/2.png "support vector") -->
<center><img src="/assets/images/SVM/2.png" width="80%" /></center>

<p><strong>Calculate the maximal margin</strong>
In order to calculate the maximal margin, we should figure out how to calculate the geometric margin which is the distance from a point to a line or hyperplane. As following figure, the point at A representing the input \(x^{(i)}\) of some training example. Its distance to the decision boundary (a line with (w, b)) is \(\gamma^{(i)}\), is given by the line segment AB. And the distance \(\gamma^{(i)}\) can be calculate in the following way:</p>

<!-- ![geometric margin](http://houxianxu.github.io/assets/images/SVM/3.png "geometric margin") -->
<center><img src="/assets/images/SVM/3.png" width="80%" /></center>

<p>vector \(BA = x_A - x_B\), unit vector is \(w/\|w\|\), so the point B is given by \(x^{(i)} - \gamma^{(i)} w/\|w\|\). And point B is on the decision boundary \(w^T x + b\), therefore</p>

\[w^T \big(x^{(i)} - \gamma^{(i)} \frac{w}{\|w\|}\big) + b = 0\]

<p>Then solving \(\gamma^{(i)}\) yields:</p>

\[\gamma^{(i)} = \frac{w^T x^{(i)} + b}{\|w\|}\]

<p>Using bias trick to represent the two parameters <strong>w</strong> and <strong>b</strong> as one, i.e. set \(x_0 = 1\) and add \(w_0\) to weights vector <strong>w</strong>.
Then we get:</p>

\[\gamma^{(i)} = \frac{w^T x^{(i)}}{\|w\|}\]

<p>Therefore based on a set of m training observations \(x_1, x_2, ..., x_m\) and associated class labels \(y_1, y_2, ..., y_m \in \big\{1, -1\big\}\), the assumption that the training set is linearly separable, the maximal margin line or hyperplane is the solution to the optimization problem.</p>

\[Maximize_{w, M} \:\:\: \frac{M}{\|w\|}  \:\:\:......... (1)\]

<p>Subject to</p>

\[y^{(i)} (W^Tx^{(i)}) = M \:\: \forall i = 1, 2, ..., m \:\:\:......... (2)\]

<p>The constrains (2) guarantees that each observation will be on the correct side of the decision boundary and the value of \(y^{(i)} (W^Tx^{(i)})\) is at least M, provided that M is positive. In addition, the margin is given by \(\frac{w^T x^{(i)}}{\|w\|}\), the objective function \((1) \frac{M}{\|w\|}\) ensures that each observation has at least a distance \(\frac{M}{\|w\|}\) from the hyperplane or decision boundary. Hence, the optimization problem choose <strong>w</strong> and <strong>M</strong> to maximize \(\frac{M}{\|w\|}\).</p>

<p><strong>Solve the optimization problem</strong></p>

<p>If we could solve the optimization problem above efficiently, then we would be done. In fact the optimization problem above is very difficult because we have a nasty objective \(\frac{M}{\|w\|}\) function, which is non-convex. So can we do better?</p>

<p>The final goal is to find the decision boundary \(w^T x = 0\), so multiplying w by some constant can affect the margin but doesn’t change the decision boundary. Therefore, we can set the value of \(w^T x_0\) for the nearest point to be 1, i.e., \(M = 1\). Additionally maximize \(\frac{1}{\|w\|}\) is the same to minimize |w|, again is the same thing as minimizing \(\|w\|^2\). Therefore we have the following optimization problem:</p>

\[Minimize_w \:\:\: \frac{1}{2}\|w\|^2  \:\:\:......... (1)\]

<p>Subject to</p>

\[y^{(i)} (W^Tx^{(i)}) = 1 \:\: \forall i = 1, 2, ..., m \:\:\:......... (2)\]

<p>The new version of optimization problem can be efficiently solved, because the objective function is a convex quadratic function and all the constrains are linear. The problem can be solved by Quadratic Program (QR) software such as <a href="http://cvxopt.org">CVXOPT</a> for Python.</p>

<h2 id="4-dual-form-kernel-and-support-vector-machine">4 Dual Form, Kernel and Support Vector Machine</h2>
<p>According to <a href="http://see.stanford.edu/materials/aimlcs229/cs229-notes3.pdf">Lagrange duality</a>, we can get the dual form of the above optimization problem.</p>

\[Maximize_{\alpha} \:\: W(\alpha) = \sum_{(i=1)}^m \alpha_i - \frac{1}{2} \sum_{i, j=1}^m y^{(i)}y^{(j)} \alpha_i \alpha_j \langle x^{(i)}, x^{(j)}\rangle\]

<p>Subject to</p>

\[\alpha_i \geq 0, \forall \: i = 1, 2, ..., m\]

\[\sum_{i=1}^m \alpha_i y^{(i)} = 0\]

<p>The \(\langle x^{(i)}, x^{(j)}\rangle = \big(x^{(i)}\big)^T x^{(j)}\), and the original <strong>w</strong> = \(\sum_i^m \alpha_i y^{(i)}x^{(i)}\). And the decision boundary becomes</p>

\[f(x) = w^T + b = \big(\sum_i^m\alpha_i y^{(i)}x^{(i)}\big)^T x + b = \sum_i^m\alpha_i y^{(i)} \langle x^{(i)}, x\rangle + b = 0\]

<p>Therefore, we can solve the dual problem (optimizing the \(\alpha\)) in lieu of solving the primal optimization problem. Specifically in order to ake a prediction, all we need to do is to calculate the inner product between the new point x and each of the training samples \(x_i\). However, it turns out that \(\alpha_i's\) will be zero except for the support vectors, so we only need to find the inner products between x and support vectors to make prediction.</p>

<p>So far, what we’ve got is just a linear classifier or linear boundary \(w^T x + b = 0\). And if we want a non-linear boundary, what we can do? Intuitively we can use non-linear items in the boundary functions such as \(wx^2\) and \(wx^3\). In general we need to use a non-linear function (g(x)) to transfer the original input x to a new value g(x) which are passed into learning algorithm. These new quantities are often called <strong>features</strong> and the original input x can be called <strong>attributes</strong>. Usually people use \(\phi(x)\) the <strong>feature mapping</strong>, which maps from attributes to features. Here is a example:</p>

\[\phi(x) =  \begin{bmatrix} x\\ x^2 \\ x^3 \end{bmatrix}\]

<p>Then the decision boundary is \(f(x) = w_1 x + w_2 x^2 + w_3 x^3 + b = 0\)</p>

<p>We should notice that the above decision boundary is a non-linear in 2-dimension space, i.e., \(w_1 x + w_2 x^2 + w_3 y + b = 0\), however we get a plane in a 3-dimension space \(w_1 x + w_2 y + w_3 z + b = 0\), which we can be solved by using maximal classifier discussed above.</p>

<p>Thus, rather than using the original input attributes x, we may instead use the features \(\phi(x)\). To do so, we just need to change the previous algorithm by replacing x with \(\phi(x)\).</p>

<p>The next question is how to choose the feature mapping, and we could choose arbitrary non-linear functions to compute features \(\phi(x)\), and then calculate the inner product of \(\phi(x)^T \phi(z)\). However, it may be very expensive to compute the features and the inner product when features are high dimension vectors.</p>

<p>One important property of the dual form is that the algorithm can be written entirely in terms of inner product \(\langle x, z\rangle\), which means that we can replace the inner product with \(\langle \phi(x), \phi(z) \rangle\). And we define the <strong>Kernel</strong> as following:</p>

\[K(x, z) = \phi(x)^T \phi(z) = \langle \phi(x), \phi(z) \rangle\]

<p>The goal is to compute the \(K(x, z)\), and the interesting is that \(K(x, z)\) may be not expensive to calculate because we don’t firsly need to compute the \(\phi(x)\) and then calculate the inner product (see following example).</p>

<p>Suppose the \(x, z \in \mathbb{R}^n\) and we can can construct the Kernel:</p>

\[K(x, z) = (x^T z)^2\]

<p>We can rewrite it as following</p>

\[\begin{equation}
     \begin{split} 
     K(x, z)
     &amp;= (x^T z)^2 \\
     &amp;= \big(\sum_{i=1}^n x_i z_i\big) \big(\sum_{j=1}^n x_j z_j) \\
     &amp;= \sum_{i=1}^n \sum_{j=1}^n x_i x_j z_i z_j \\
     &amp;= \sum_{i, j=1}^n (x_i x_j)(z_i z_j)
    \end{split}
    \end{equation}\]

<p>We can see \(K(x, z) = \phi(x)^T \phi(z)\), where the \(\phi(x)\) is shown below (take n = 3)</p>

\[\phi(x) = \begin{bmatrix} x_1x_1\\ x_1x_2 \\x_1x_3\\x_2x_1\\x_2x_2\\x_2x_3\\x_3x_1\\x_3x_2\\x_3x_3 \end{bmatrix}\]

<p>So we can efficiently calculate the \(K(x, z) = (x^T z)^2\) in \(O(n)\) because of n-dimension input attributes x. However, it takes \(O(n^2)\) to calculate \(\phi(x)\).</p>

<p>In general, we can also use \(K(x, z) = (X^T z + c)^d\) to achieve feature mapping, which is known as <strong>ploynomial kernel</strong> of degree <strong>d</strong>. This kernel essentially amount to fitting a support vector classifier in a higher-dimensional space involving polynomials of degree d, which leads to a much more flexible decision boundary. Notice that though working in a very high dimension space, we only need \(O(n)\) time to compute the K(x, z) because we never need to explicitly represent feature vectors in the very high dimensional feature space.</p>

<p>Another popular choice is <strong>Gaussian Kernel</strong> or <strong>Radial Kernel</strong>:</p>

\[K(x, z) = exp \big( - \frac{(x-z)^2} {2 \sigma^2} \big)\]

<p>We can use Taylor expansion to expand the Gaussian Kernel (\(e^x = \sum_{n=0}^\infty \frac {x^n} {n!}\)), and we can see that the feature vector that corresponds to the Gaussian kernel has infinite dimensionality, and the feature space is implicit.</p>

<p>How does the Kernel work? One intuition is to think of \(K(x, z)\) as a measurement of how similar are \(\phi(x)\) and \(\phi(z)\), or of how similar are x and z. If  \(\phi(x)\) and  \(\phi(z)\) are close to each other, then \(K(x, z) = \phi(x)^T \phi(z)\) is expected to large, otherwise \(\phi(x)\) and  \(\phi(z)\) are far apart, then \(K(x, z)\) is small. Recall that we use the sign of</p>

\[f(x) = w^T + b =\sum_i^m\alpha_i y^{(i)} \langle x^{(i)}, x\rangle + b =\sum_i^m\alpha_i y^{(i)} \langle \phi(x^{(i)}), \phi(x)\rangle + b\]

<p>for prediction. Look at Gaussian Kernel, if training observations that are far from test observation x will play essentially little role in the predicted class label for x. This means that Gaussian Kernel has a local hehavior, in the sense that only nearby training observations have a big effect on a class label for test observation.</p>

<p>The <strong>Support Vector Machine</strong> is an extension of the support vector classifier that results from enlarging the feature space in a specific way, using kernels.</p>

<h2 id="5-the-non-separable-case">5 The Non-separable Case</h2>
<p>The SVMs work very well for classification if a separating hyperplane exists, however, we will get stuck when the data is overlapped and non-separable because there is no max margin. So we can extend the separating hyperplane in order to almost separate the classes based on soft margin. We instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane. We reformulate the optimization problem as follows:</p>

\[Minimize_w \:\:\: \frac{1}{2}\|w\|^2 + C \sum_{i=1}^m \zeta_i\]

<p>Subject to</p>

\[y^{(i)} (W^Tx^{(i)}) = 1 -\zeta_i \:\: \forall i = 1, 2, ..., m\]

<p>Thus, we permit the observation to be on the incorrect side of the margin, or even the incorrect side of the hyperplane (\(1-\zeta_i &lt; 0\)), and we pay a cost of the objective function being increased by \(C\zeta_i\). The big number C ensuring that \(\zeta_i\) is small and most examples have at least soft max margin.</p>

<p>And the dual form is as follows:</p>

\[Maximize_{\alpha} \:\: W(\alpha) = \sum_{(i=1)}^m \alpha_i - \frac{1}{2} \sum_{i, j=1}^m y^{(i)}y^{(j)} \alpha_i \alpha_j \langle x^{(i)}, x^{(j)}\rangle\]

<p>Subject to</p>

\[0 \leq \alpha_i \geq C, \forall \: i = 1, 2, ..., m\]

\[\sum_{i=1}^m \alpha_i y^{(i)} = 0\]

<p>Above is the basic idea of Support Vector Machine (SVM), all that remains is to to find a algorithm for solving the dual problem. The SMO (sequential minimal optimization) algorithm give an efficient way to solve the dual problem. You can find the details <a href="http://cs229.stanford.edu/materials/smo.pdf">here</a>.</p>

<h2 id="6-multiclass-classification">6 Multiclass classification</h2>
<p>We need to generalize to the multiple class case, that’s to say, the value of y is not binary any more, instead y can equal to 0, 1, 2, …, k.</p>

<p>####Transfer multi-class classification into binary classification problem</p>

<p>We need change multiple classes into two classes, and the idea is to construct several logistic classifier for each class. We set the value of y (label) of one class to 1, and 0 for other classes. Thus, if we have K classes, we build K SVM and use it for prediction. The idea is the same as use <a href="http://houxianxu.github.io/logistic-softmax-regression/#multiclass">logistic regression</a> for multi-classification.
<!-- ![One vs all](http://houxianxu.github.io/assets/images/logisticRegression/4.png "Figure 4") --></p>
<center><img src="/assets/images/logisticRegression/4.png" width="80%" /></center>

<h4 id="multi-class-support-vector-machine-loss">Multi-class Support Vector Machine loss</h4>
<p>Similar to <a href="http://houxianxu.github.io/logistic-softmax-regression/">softmax</a>, For mutilple classes problems (K categoires), it is possible to establish a mapping function for each class. We can simply use a linear mapping for all classes (K mapping function):</p>

\[f(x^{(i)}, W, b) = Wx^{(i)} + b =f(x^{(i)}, W) = Wx^{(i)} \:(bias \: trick)\]

<p>Intuitively we wish that the correct class has a score that is higher than the scores of incorrect classes. Thus, we can predict the test observation as the class with the highest score. Next we should find a loss function to optimize the parameters.</p>

<p>For sample \(x_i\), the vector \(f(x_i, W)\) is the scores for all the classes, \(y_i\) is the correct class and \(f(x_i, W)_{y_i}\) is the score corresponding to the correct class for \(x_i\). The score for the \(j^{th}\) class is \(f(x_i, W)_j\). The multiclass SVM loss for the \(i^{th}\) sample is as follows:</p>

\[\begin{equation}
     \begin{split} 
		L_i &amp;= \sum_{j\neq y_i} max(0, f(x_i, W)_j - f(x_i, W)_{y_j} + \Delta) \\
	   		&amp;= \sum_{j\neq y_i} max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)
	\end{split}
    \end{equation}\]

<p>Though the expression seems complex, the interpretation is relatively simple. Firstly every class contribute to the loss of one sample, and the correct class doesn’t lead to loss. We want the correct class for sample \(x_i\) have a score \(f(x_i, W)_{y_j}\) higher than the incorrect classes \(f(x_i, W)_j\) by some fixed margin. If the incorrect class score adds some fix margin still less than correct class score, i.e., \(f(x_i, W)_j + \Delta &lt; f(x_i, W)_{y_j}\), then set the loss to be zero. Because the correct score is “much” big than than the incorrect scores, which we desire to achieve. However, if the the correct class score is not “big” enough or even less than the incorrect class scores, then we set the loss to be \(f(x_i, W)_j + \Delta - f(x_i, W)_{y_j}\). Additionally the function max(0, -) is often called the <strong>hinge loss</strong>.</p>

<p>We still need regularization to our loss function. Suppose that we’ve got a set of weights <strong>W</strong> that can correctly classify all the samples, then the set of <strong>W</strong> is not necessarily unique. Firstly if we multiply a number \(\lambda\) <strong>W</strong>, then the decision boundary remains the same. So the scores stretches accordingly but the magin \(\Delta\) doesn’t change. Usually people add \(L_2\) regularization penalty <strong>R(W)</strong> to loss function.</p>

\[R(W) = \sum_k \sum_l W_{k, l}^2\]

<p>So the full loss is as follows:</p>

\[\begin{equation}
     \begin{split}  
		L &amp;= \frac{1}{m} \sum_i L_i + \lambda R(W) \\
		  &amp;= \frac{1}{m} \sum_i \sum_{j \neq y_{y_i}} [max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)] + \lambda \sum_k \sum_l W_{k, l}^2
	\end{split}
    \end{equation}\]

<p>When \(\lambda\) is big, then \(R(W) = \sum_k \sum_l W_{k, l}^2\) is small. From binary SVM above, we know that the distance between one observation and the hyperplane of correct class is \(\frac{f(x_i, W)_{y_j}} {\|w_{k}\|}\). therefore, the \(L_2\) penalty leads to the <strong>max margin</strong> property in SVMs and improve the generalization of the performance of the classifiers and avoid overfitting.</p>

<p>This loss function has no constrains and we can calculate the gradient and optimize the <strong>W</strong> using gradient descent algorithm.
For single example the SVM loss is:</p>

\[L_i = \sum_{j\neq y_i} max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)\]

<p>We can differentiate the function with respect to weights. For <strong>w</strong> corresponding to the correct class:</p>

\[\nabla_{w_{y_i}} L_i = - \big(\sum_{y \neq y_i} \mathbb{1}(w_j^T x_i - w_{y_i}^T x_i + \Delta 0)\big) x_i\]

<p>The gradient for incorrect class:</p>

\[\nabla_{w_j} L_i = \mathbb{1}(w_j^T x_i - w_{y_i}^T x_i + \Delta 0) x_i\]

<p>where \(\mathbb{1}\) is the indicator function that is one if the condition is true or zero otherwise.</p>

<h2 id="7-get-your-hands-dirty-and-have-fun">7 Get your hands dirty and have fun</h2>
<ul>
  <li>Purpose: Implement multi-classification classifier.</li>
  <li>Data: CIFAR-10 dataset, consists of 60000 32x32 colour images in 10 classes, with 6000 images per class. There are 50000 training images and 10000 test images. The data is available <a href="http://www.cs.toronto.edu/~kriz/cifar.html">here</a>.</li>
  <li>Setup: I choose Python (IPython, numpy etc.) on Mac for implementation, and the results are published in a IPython notebook.</li>
  <li><a href="http://houxianxu.github.io/implementation/SVM.html">click here</a> for the implementation.</li>
  <li>Following is code to implement the logistic, one-vs-all and softmax classifiers by gradient decent algorithm.</li>
</ul>

<p><strong>classifiers: algorithms/classifiers.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">algorithms.classifiers.loss_grad_logistic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">algorithms.classifiers.loss_grad_softmax</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">algorithms.classifiers.loss_grad_svm</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">LinearClassifier</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># set up the weight matrix 
</span>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">sgd</span><span class="sh">'</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
              <span class="n">reg</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Train linear classifier using batch gradient descent or stochastic gradient descent

        Parameters
        ----------
        X: (D x N) array of training data, each column is a training sample with D-dimension.
        y: (N, ) 1-dimension array of target data with length N.
        method: (string) determine whether using </span><span class="sh">'</span><span class="s">bgd</span><span class="sh">'</span><span class="s"> or </span><span class="sh">'</span><span class="s">sgd</span><span class="sh">'</span><span class="s">.
        batch_size: (integer) number of training examples to use at each step.
        learning_rate: (float) learning rate for optimization.
        reg: (float) regularization strength for optimization.
        num_iters: (integer) number of steps to take when optimization.
        verbose: (boolean) if True, print out the progress (loss) when optimization.

        Returns
        -------
        losses_history: (list) of losses at each training iteration
        </span><span class="sh">"""</span>

        <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">num_classes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># assume y takes values 0...K-1 where K is number of classes
</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># initialize the weights with small values
</span>            <span class="k">if</span> <span class="n">num_classes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># just need weights for one class
</span>                <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># weigths for each class
</span>                <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>

        <span class="n">losses_history</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_iters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">bgd</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># randomly choose a min-batch of samples
</span>                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">num_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">)</span> <span class="c1"># grad =[K x D]
</span>            <span class="n">losses_history</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

            <span class="c1"># update weights
</span>            <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span> <span class="c1"># [K x D]
</span>            <span class="c1"># print self.W
</span>            <span class="c1"># print 'dsfad', grad.shape
</span>            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">print</span> <span class="sh">'</span><span class="s">iteration %d/%d: loss %f</span><span class="sh">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_iters</span><span class="p">,</span> <span class="n">loss</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">losses_history</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Predict value of y using trained weights

        Parameters
        ----------
        X: (D x N) array of data, each column is a sample with D-dimension.

        Returns
        -------
        pred_ys: (N, ) 1-dimension array of y for N sampels
        h_x_mat: Normalized scores
        </span><span class="sh">"""</span>
        <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">f_x_mat</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">Logistic</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">f_x_mat</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">()</span> <span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># multiclassification
</span>            <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">f_x_mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># normalized score
</span>        <span class="n">h_x_mat</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">f_x_mat</span><span class="p">))</span> <span class="c1"># [1, N]
</span>        <span class="n">h_x_mat</span> <span class="o">=</span> <span class="n">h_x_mat</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pred_ys</span><span class="p">,</span> <span class="n">h_x_mat</span>

    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Compute the loss and gradients.

        Parameters
        ----------
        The same as self.train()

        Returns
        -------
        a tuple of two items (loss, grad)
        loss: (float)
        grad: (array) with respect to self.W
        </span><span class="sh">"""</span>
        <span class="k">pass</span>

<span class="c1"># Subclasses of linear classifier
</span><span class="k">class</span> <span class="nc">Logistic</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A subclass for binary classification using logistic function</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_logistic_vectorized</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_logistic_naive</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Softmax</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A subclass for multi-classicication using Softmax function</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_softmax_vectorized</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_softmax_naive</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SVM</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A subclass for multi-classicication using SVM function</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">loss_grad_svm_vectorized</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span></code></pre></figure>

<p><strong>Function to compute loss and gradients for SVM classification: algorithms/classifiers/loss_grad_svm.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># file: algorithms/classifiers/loss_grad_svm.py
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">loss_grad_svm_vectorized</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Compute the loss and gradients using softmax function 
    with loop, which is slow.

    Parameters
    ----------
    W: (K, D) array of weights, K is the number of classes and D is the dimension of one sample.
    X: (D, N) array of training data, each column is a training sample with D-dimension.
    y: (N, ) 1-dimension array of target data with length N with lables 0,1, ... K-1, for K classes
    reg: (float) regularization strength for optimization.

    Returns
    -------
    a tuple of two items (loss, grad)
    loss: (float)
    grad: (K, D) with respect to W
    </span><span class="sh">"""</span>

    <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">num_train</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># compute all scores
</span>    <span class="n">scores_mat</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># [C x N] matrix
</span> 
    <span class="c1"># get the correct class score 
</span>    <span class="n">correct_class_score</span> <span class="o">=</span> <span class="n">scores_mat</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="c1"># [1 x N]
</span>    
    <span class="n">margins_mat</span> <span class="o">=</span> <span class="n">scores_mat</span> <span class="o">-</span> <span class="n">correct_class_score</span> <span class="o">+</span> <span class="n">delta</span> <span class="c1"># [C x N]
</span>
    <span class="c1"># set the negative score to be 0
</span>    <span class="n">margins_mat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">margins_mat</span><span class="p">)</span>
    <span class="n">margins_mat</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">margins_mat</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_train</span>

    <span class="c1"># add regularization to loss
</span>    <span class="n">loss</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>

    <span class="c1"># compute gradient
</span>    <span class="n">scores_mat_grad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">scores_mat</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># compute the number of margin 0 for each sample
</span>    <span class="n">num_pos</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">margins_mat</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">scores_mat_grad</span><span class="p">[</span><span class="n">margins_mat</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">scores_mat_grad</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">num_pos</span>

    <span class="c1"># compute dW
</span>    <span class="n">dW</span> <span class="o">=</span> <span class="n">scores_mat_grad</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_train</span> <span class="o">+</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">W</span>
    
    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">dW</span></code></pre></figure>

<h2 id="11-reference-and-further-reading">11. Reference and further reading</h2>
<ul>
  <li>Andrew Ng’s <a href="https://www.coursera.org/course/ml">Machine learning on Coursera</a></li>
  <li>Machine learning notes on <a href="http://see.stanford.edu/materials/aimlcs229/cs229-notes3.pdf">Stanford Engineering Everywhere (SEE)</a></li>
  <li>Stanford University open course <a href="http://vision.stanford.edu/teaching/cs231n/">CS231n</a></li>
  <li>The University of Nottingham <a href="http://modulecatalogue.nottingham.ac.uk/Nottingham/asp/moduledetails.asp?year_id=000113&amp;crs_id=021211">Machine Learning Module</a></li>
</ul>

<!-- ## New idea:
- asymmetric prediction, max margins for two classes are different.
- Two mimimal margin classifier
 -->]]></content><author><name></name></author><summary type="html"><![CDATA[The support vector machine algorithm for classification]]></summary></entry><entry><title type="html">Logistic and Softmax Regression</title><link href="http://houxianxu.github.io/blog/2015/logistic-softmax-regression/" rel="alternate" type="text/html" title="Logistic and Softmax Regression" /><published>2015-04-23T00:00:00+00:00</published><updated>2015-04-23T00:00:00+00:00</updated><id>http://houxianxu.github.io/blog/2015/logistic-softmax-regression</id><content type="html" xml:base="http://houxianxu.github.io/blog/2015/logistic-softmax-regression/"><![CDATA[<blockquote>
  <p>In this post, I try to discuss how we could come up with the logistic and softmax regression for classification. I also implement the algorithms for image classification with <a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10 dataset</a> by Python (numpy). <a href="http://houxianxu.github.io/implementation/LogisticRegression.html">The first one</a>) is binary classification using logistic regression, <a href="http://houxianxu.github.io/implementation/One-vs-All-LogisticRegression.html">the second one</a> is multi-classification using logistic regression with one-vs-all trick and <a href="http://houxianxu.github.io/implementation/SoftmaxRegression.html">the last one</a>) is mutli-classification using softmax regression.</p>
</blockquote>

<!-- more -->

<h2 id="1-problem-setting">1. Problem setting</h2>
<p>Classification problem is to classify different objects into different categories. It is like regression problem, except that the predictor y just has a small number of discrete values. For simplicity, we just focus on <strong>binary classification</strong> that y can take two values 1 or 0 (indicating two classes).</p>

<h2 id="2-basic-idea">2. Basic idea</h2>
<p>We could plot the data on a 2-D plane and try to figure out whether there is any structure of the data (see following figure).</p>

<!-- ![Scatter Plot of Two variables](http://houxianxu.github.io/images/logisticRegression/1.png "Figure 1") -->
<p><img src="/assets/images/logisticRegression/1.png" width="80%" /></p>

<p>From the particular example above, it is not hard to figure out we could find a line to separate the two classes. Specifically we divide the 2-D plane into 2 parts according to a line, and then we can predict new sample by observing which part it belongs to. Mathematically if \(z = w_0 + w_1x_1 + w_2x_2\) &gt;= 0, then y = 1; if \(z = w_0 + w_1x_1 + w_2x_2\) &lt; 0, then y = 0. We can regard the linear function \(w^Tx\) as a mapping from raw sample data (\(x_1, x_2\)) to classes scores. Intuitively we wish that the “correct” class has a score that is higher than the scores of “incorrect” classes.</p>

<h2 id="3-how-to-find-the-best-line">3. How to find the best line</h2>
<p>The hypothesis is a linear model \(w_0 + w_1x_1 + w_2x_2 = W^TX\), the threshold is z = 0. The score value of z depends on the distance between the point and the target line, and the absolute value of z could be very large or small. We could <strong>normalize the distances</strong> for convenience, however, we had better not use linear normalization such as x / (max(x) - min(x)) and x / (std(x)), because the distinction between the two classes is more obvious when the absolution value of z is larger. Sigmoid or logistic function is well-known to be used here, following is the function and plot of sigmoid function.</p>

\[g(z) = \frac{1}{1 + e^{-z}}\]

<!-- ![Sigmoid function](http://houxianxu.github.io/images/logisticRegression/2.png "Figure 2") -->
<p><img src="/assets/images/logisticRegression/2.png" width="100%" /></p>

<p>The new model for classification is:</p>

<p>\(h(x) = \frac{1}{1 + e^{-w^Tx}}\)
We can see from the figure above that when z 0, g(z) 0.5 and when the absolute vaule of v is very large the g(z) is more close to 1. By feeding the score to sigmoid function, not only the scores can be normalized from 0 to 1, which can make it much easier to find the loss function, but also the result can be interpreted from probabilistic aspect.</p>

<h2 id="4-figure-out-the-loss-function">4. Figure out the loss function</h2>
<p>we need to find a way to measure the agreement between the predicted scores and the ground truth value.</p>

<p><strong>Naive idea</strong></p>

<p>We could use least square loss after normalizing the training data, the result is as following:
\(L_0 = \frac{1}{m} \sum_{i=1}^m(h(x^{(i)}) - y^{(i)})^2 = \frac{1}{m} \sum_{i=1}^m(\frac{1}{1 + e^{-w^Tx^{(i)}}} - y^{(i)})^2\), where \(x^{(i)}\) is a vector for all features \(x_j^{(i)}\) (j=0,1, … , n) for single sample i, and \(y^{(i)}\) is the target value for this example. However this loss function is not a convex function because of sigmoid function used here, which will make it very difficult to find the w to opimize the loss.</p>

<p><strong>Can we do better?</strong></p>

<p>Because of this is a binary classification problems, we can compute the loss for the two classes respectively. When target y = 1, the loss had better be very large when \(h(x) = \frac{1}{1 + e^{-w^Tx}}\) is close to zero, and the loss should be very small when h(x) is close to one; in the same way, when target y = 0, the loss had better be very small when h(x) is close to zero, and the loss should be very large when h(x) is close to one. In fact, we can find this kind of function:</p>

\[L(h(x), y) =\begin{cases} -log(h(x)) &amp; y = 1\\ -log(1 - h(x)) &amp; y  = 0 \end{cases} =L(h(x), y) = -ylog(h(x)) - (1-y)log(1-h(x))\]

<p>So the total loss: \(L(w) = - \frac{1}{m} \sum_{i = 1}^m [y^{(i)}logh(x^{(i)}) + (1 - y^{(i)}) log(1-h(x^{(i)}))]\)</p>

<p>\(x^{(i)}\) is a vector for all \(x_j\) (j=0,1, … , n), and \(y^{(i)}\) is the target value for this example.</p>

\[h(x) = \frac{1}{1 + e^{-w^Tx}}\]

<p>The plots of loss function are shown below, and they meet the desirable properties discribed above.
<!-- ![Loss function](http://houxianxu.github.io/images/logisticRegression/3.png "Figure 3") -->
<img src="/assets/images/logisticRegression/3.png" width="100%" /></p>

<h2 id="5-find-the-best-w-to-minimize-the-loss">5 Find the best w to minimize the loss</h2>
<p>Like <a href="http://houxianxu.github.io/linear-regression-post/">linear regression</a> we can use <strong>gradient descent algorithm</strong> to optimize w step by step.
Compute the gradient for just one sample:</p>

\[\begin{equation}
     \begin{split} 
     \frac{\partial}{\partial w_j} L(w) 
     &amp;= -(y \frac{1}{g(w^Tx)} - (1-y)  \frac{1}{1 - g(w^Tx)})  \frac{\partial}{\partial w_j} g(w^Tx) \\
     &amp;= -(y \frac{1}{g(w^Tx)} - (1-y)  \frac{1}{1 - g(w^Tx)})  g(w^Tx)(1 - g(w^Tx)) \frac{\partial}{\partial w_j} w^Tx \\
     &amp;= -(y(1-g(w^Tx)) - (1-y)g(w^Tx))x_j \\
     &amp;= (h(x)-y)x_j                                    
    \end{split}
    \end{equation}\]

<p>So the gradients are as following when considering all the samples:</p>

\[\frac{\partial}{\partial w_j} L(w) = \frac{1}{m} \sum_{i = 1}^m (h(x)-y)x_j\]

<p>Then we can use <strong>batch decent algorithm</strong> or <strong>stochastic decent algorithm</strong> to optimize <strong>w</strong>, i.e, \(w := w + \alpha \frac{\partial}{\partial w_j} L(w)\)</p>

<p>We can see that the gradient or partial derivative is the same as gradient of linear regression except for the h(x). We can get a better understanding of this when interpreting the loss function from probabilistic aspect.</p>

<h2 id="6-probabilistic-interpretation">6. Probabilistic interpretation</h2>
<p>Let us regard the value of h(x) as the probability:</p>

\[\begin{cases} P(y=1|x;w) = h(x) \\ P(y = 0 | x; w) = 1 - h(x) \end{cases} =P(y|x;w) = (h(x))^y(1-h(x))^{1-y}\]

<p>So the likelihood is:</p>

\[\begin{equation}
     \begin{split} 
     L(w) &amp;= p(y|X; w) \\ 
     &amp;= \prod_{i = 1}^m p(y^{(i)}|x^{(i)};w) \\
     &amp;= \prod_{i = 1}^m (h(x^{(i)}))^{y^{(i)}} (1-h(x^{(i)}))^{1-y^{(i)}} \\                               
    \end{split}
    \end{equation}\]

<p>And the log likelihood:</p>

\[\begin{equation}
     \begin{split} 
     l(w) = log(L(w))
     &amp;= \sum_{i = 1}^m y^{(i)} log(x^{(i)}) + (1 - y^{(i)}) log(1 - h(x^{(i)}))                            
    \end{split}
    \end{equation}\]

<p>This equation is the same as the the loss function when picking minus, so minimize the loss can be interpreted as maximize the likelihood of the y when given x <code class="language-plaintext highlighter-rouge">p(y|x)</code>. What’s more, the value of h(x) can be interpreted as the probability of the sample to be classified to y = 1. I think this is why most people prefer sigmoid function for normalization, theoretically we can choose other functions that smoothly increase from 0 to 1.</p>

<p>After we optimize the w, we get a line in 2-D space and the line is usually called decision boundary (h(x) = 0.5). We can also generalize to binary classification on n-D space, and the corresponding decision boundary is a (n-1) Dimension hyperplane (subspace) in n-D space.</p>

<p><a name="multiclass"></a></p>

<h2 id="7-multiclass-classification--one-vs-all">7. Multiclass classification – One vs all</h2>
<p>We need to generalize to the multiple class case, that’s to say, the value of y is not binary any more, instead y can equal to 0, 1, 2, …, k.</p>

<h4 id="basic-idea--transfer-multi-class-classification-into-binary-classification-problem">Basic idea – Transfer multi-class classification into binary classification problem</h4>
<p>We need change multiple classes into two classes, and the idea is to construct several logistic classifier for each class. We set the value of y (label) of one class to 1, and 0 for other classes. Thus, if we have K classes, we build K logistic classifiers and use it for prediction. There is a potential problem that one sample might be classified to several classes or non-class. The solution is to compare all the values of h(x) and classify the sample to the class with the highest value of h(x). The idea is shown in following figure (From Andrew’s notes).</p>

<!-- ![One vs all](http://houxianxu.github.io/images/logisticRegression/4.png "Figure 4") -->

<p><img src="/assets/images/logisticRegression/4.png" width="100%" /></p>

<h2 id="8-can-we-do-better--softmax">8. Can we do better? – Softmax</h2>
<p>In logistic regression classifier, we use linear function to map raw data (a sample) into a score z, which is feeded into logistic function for normalization, and then we interprete the results from logistic function as the probability of the “correct” class (y = 1). We just need a mapping function here because of just two classes (just need to decide whether one sample belongs to one class or not).
For multiple classes problems (K categories), it is possible to establish a mapping function for each class. As above we can simply use a linear mapping for all classes (K mapping function):</p>

\[f(x^{(i)}, W, b) = Wx{(i)} + b\]

<p>Where \(x^{(i)}\) is a vector for all features \(x_j^{(i)}\) (j=0,1, … , n) for single sample i, and \(x^{(i)}\) is a single column vector of shape \([D, 1]\). <strong>W</strong> is a matrix of shape \([K, D]\) called <strong>weights</strong>, <strong>K</strong> is the number of categories, and <strong>b</strong> is a vector of \([K, 1]\) called <strong>bias vector</strong>. It is a little cumbersome to keep track of two sets of parameters (<strong>W</strong> and <strong>b</strong>), in factor we can combine the two into a single matrix. Specifically we can extend the feature vector \(x^{(i)}\) with an addition bias dimension holding constant 1, while extending <strong>W</strong> matrix with a new column (at the first or last column). Thus we get score mapping function:</p>

\[f(x^{(i)}, W) = Wx^{(i)}\]

<p>Where <strong>W</strong> is a matrix of shape \([K, D+1]\), \(x^{(i)}\) is vector of shape \([D+1, 1]\), and \(f(x^{(i)}, W)\) is a vector of shape \([K, 1]\) indicating the different scores of every class for the \(i^{th}\) sample.</p>

<h4 id="find-the-loss-function">Find the loss function</h4>
<p>Similar to logistic regression classifier, we need to normalize the scores from 0 to 1. However we should not use a linear normalization as discussed in the logistic regression because the bigger the score of one class is, the more chance the sample belongs to this category. What’s more, the chance is similar high when the scores are very large (see the plot of logistic function above).
Similar to logistic function, people use exponential function (non-linear) to preprocess the scores and then compute the percentage of each score in the sum of all the scores. What’s more, the percentages can be interpreted as the probability of each class for one sample. Here is formula for the \(i^{th}\) sample:</p>

\[h(x^{(i)}) = \frac{e^{w_{y_j}^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}}\]

<p>Here is the plot of h(x) for two classes in 3D space, you can rotate the graph by clicking the arrows to get a better understanding the shape of the h(x).
Where \(x^{(i)}\) is vector of all features of sample i, \(w_j\) is the weights for the \(j^{th}\) class, and \(y_j\) is the correct class for the \(i^{th}\) sample.</p>

<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,0,0" width="600" height="700" id="function_plotter" align="middle">
  <param name="movie" value="http://dwudljvm154gg.cloudfront.net/graph3d.swf?lpf=e^x / (e^x%2Be^y)&amp;lpxmin=-5&amp;lpxmax=5&amp;lpymin=-5&amp;lpymax=5&amp;lpzmin=0&amp;lpzmax=1" />
  <param name="quality" value="high" />
  <param name="bgcolor" value="#ffffff" />
  <embed src="http://dwudljvm154gg.cloudfront.net/graph3d.swf?lpf=e^x / (e^x%2Be^y)&amp;lpxmin=-3&amp;lpxmax=3&amp;lpymin=-3&amp;lpymax=3&amp;lpzmin=0&amp;lpzmax=1" quality="high" bgcolor="#ffffff" width="700" height="750" name="function_plotter" align="middle" allowscriptaccess="sameDomain" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" />
</object>

<p>So why exponential function? In my opinion, it is natually to come up with.</p>

<ul>
  <li>It is a very simple and widely used non-linear function</li>
  <li>This function is strictly increasing</li>
  <li>This function is a convex function and its derivative is strictly increasing. That’s to say, when the score is large, then make it even more larger.</li>
</ul>

<p>The lesson is that we should put exponential function in our toolbox for non-linear problems</p>

<p>After normalizing the scores, we can use the same concept to define the loss function, which should make the loss small when the normalized score of h(x) is large, and penlize more when h(x) is small. Thus, we can use \(-log(h(x))\) to compute the loss, and the loss for one sample is as following:</p>

\[L_i = -log \big(h(x^{(i)})\big) = -log \big(\frac{e^{f_{y_j}^{(i)}}} {\sum_{j = 1}^k e^{f_j^{(i)}}}\big) = -log \big(\frac{e^{w_{y_j}^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}}\big)\]

<p>Total loss for all sample is:</p>

\[L = \frac{1}{m} \sum_{i = 1}^m L_i = - \frac{1}{m} \sum_{i = 1}^m log \big(h(x^{(i)})\big) = - \frac{1}{m} \sum_{i = 1}^m log \big(\frac{e^{f_{y_j}^{(i)}}} {\sum_{j = 1}^k e^{f_j^{(i)}}}\big) = - \frac{1}{m} \sum_{i = 1}^m log \big(\frac{e^{w_{y_j}^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}}\big)\]

<h4 id="calculate-the-gradient-one-sample">Calculate the gradient (one sample)</h4>

\[\begin{equation}
  \begin{split} 
      \nabla_{w_j} L_i &amp;= - \nabla_{w_j} log \big(\frac{e^{w_{y_j}^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}}\big) \\
      &amp;= -\nabla_{w_j} \big(w_{y_j}^Tx^{(i)}\big) + \nabla_{w_j} log \big(\sum_{j = 1}^k e^{w_j^Tx^{(i)}}\big)  \end{split}
  \end{equation}\]

<p>So the gradient with respect to \(w_{y_j}\) (\(y_j\) is the correct class):
\(\nabla_{w_{y_j}} = -x^{(i)} + \frac{e^{w_j^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}} x^{(i)}\)</p>

<p>The gradient with respect to \(w_j\):
\(\nabla_{w_j} = \frac{e^{w_j^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}} x^{(i)}\)</p>

<h4 id="is-there-any-problem-with-the-loss-function">Is there any problem with the loss function</h4>
<p>When writing code to implement the softmax function in practice, we should first compute the intermediate terms \(e^{f_j}\) to make the scores bigger and use a logarithm function to make the score smaller. However, the value of \(e^{f_j}\) may be very large due to the exponentials and dividing large numbers could be numerically unstable, so we should make \(e^{f_j}\) smaller before division. Here is the trick by multiply the numerator and denominator by a constant C:</p>

\[\frac{e^{f_{y_j}^{(i)}}} {\sum_{j = 1}^k e^{f_j^{(i)}}} = \frac{C e^{f_{y_j}^{(i)}}} {C \sum_{j = 1}^k e^{f_j^{(i)}}} = \frac{e^{f_{y_j}^{(i)} + logC}} {\sum_{j = 1}^k e^{f_j^{(i)} + logC}}\]

<p>Because we have the flexibility to choose any number of C, we can choose C to make \(e^{f_j^{(i)}} + logC\) small. A common choice for C is to set \(logC = -max_jf_j^{(i)}\). This trick makes the highest value of \(f_j^{(i)} + logC\) to be zero and less than 0 for others. So the values of \(e^{f_j^{(i)}} + logC\) are restricted from 0 to 1, which should be more appropriate for division.</p>

<h4 id="probabilistic-interpretation">Probabilistic interpretation</h4>
<p>We can interpret \(h(x) = P(y^{(i)}) = \frac{e^{w_{y_j}^Tx^{(i)}}} {\sum_{j = 1}^k e^{w_j^Tx^{(i)}}}\) as the normalized probability of assigned to the correct label \(y^{(i)}\) given sample x^{(i)} and parameters <strong>W</strong>. Firstly the score \(f(x^{(i)}, W) = Wx^{(i)}\) can be interpreted as the unnormalized log probabilities. Then exponentiating the scores with on-linear function \(e^x\) gives the unnormalized probabilities (may call frequency). Last using division for normalization to make the probabilities sum to one. Like logistic regression, the minimize the negative log likelihood of the correct class can also be interpreted as performing <strong>Maximum Likelihood Estimation</strong>. The loss function can be also deduced from probabilistic theory like logistic regression, in fact linear regression, logistic regression and softmax regression all belong to <a href="http://en.wikipedia.org/wiki/Generalized_linear_model">Generalized Linear Model</a>.</p>

<h2 id="8-regularization-to-avoid-overfitting">8. Regularization to avoid overfitting</h2>
<p>In practice we often add a <strong>regularization loss</strong> to the loss function provided above to penalize large <strong>weights</strong> to improve generalization. The most common regularization penalty <strong>R(W)</strong> is the <strong>L2</strong> norm.</p>

\[R(W) =  \sum_k  \sum_d W_{k, d}^2\]

<p>So the total loss is the <strong>data loss</strong> and the <strong>regularization loss</strong>, so the full loss becomes:</p>

\[L = \frac{1}{m} \sum_{i = 1}^m L_i + \frac{1}{2} \lambda \sum_k  \sum_d W_{k, d}^2\]

<p>The advantage of penalizing large weights is to improve generalization and make the trained model work well for unseen data, because it means that no input dimension can have a very large influence on the scores all by itself and the final classifier is encouraged to take into account allnput dimensions to small amounts rather than a few dimensions and very strongly. Note that biases do not have the same effect as other parameters and do not control the strength of influence of an input dimension. So some people only regularize the weights <strong>W</strong> but not the biases, however, I regularize both in the implementation both for simplicity and better performance.</p>

<p>I have written <strong>another post</strong> to discuss regularization in more details, especially how to interpret it. You can find the post <a href="">here</a>.</p>

<h2 id="9-get-your-hands-dirty-and-have-fun">9. Get your hands dirty and have fun</h2>
<ul>
  <li>Purpose: Implement logistic regression and softmax regression classifier.</li>
  <li>Data: CIFAR-10 dataset, consists of 60000 32x32 colour images in 10 classes, with 6000 images per class. There are 50000 training images and 10000 test images. The data is available <a href="http://www.cs.toronto.edu/~kriz/cifar.html">here</a>.</li>
  <li>Setup: I choose Python (IPython, numpy etc.) on Mac for implementation, and the results are published in a IPython notebook.
    <ul>
      <li><a href="http://houxianxu.github.io/implementation/LogisticRegression.html">click here</a> for logistic regression classification.</li>
      <li><a href="http://houxianxu.github.io/implementation/One-vs-All-LogisticRegression.html">click here</a> for logistic multi-classification by one-vs-all trick.</li>
      <li><a href="http://houxianxu.github.io/implementation/SoftmaxRegression.html">click here</a> for softmax multi-classification.</li>
    </ul>
  </li>
  <li>Following is code to implement the logistic, one-vs-all and softmax classifiers by gradient decent algorithm.</li>
</ul>

<p><strong>classifiers: algorithms/classifiers.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># file: algorithms/classifiers.py
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">algorithms.classifiers.loss_grad_logistic</span> <span class="kn">import</span> <span class="o">*</span> 

<span class="k">class</span> <span class="nc">LinearClassifier</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># set up the weight matrix 
</span>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">sgd</span><span class="sh">'</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
              <span class="n">reg</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Train linear classifier using batch gradient descent or stochastic gradient descent

        Parameters
        ----------
        X: (D x N) array of training data, each column is a training sample with D-dimension.
        y: (N, ) 1-dimension array of target data with length N.
        method: (string) determine whether using </span><span class="sh">'</span><span class="s">bgd</span><span class="sh">'</span><span class="s"> or </span><span class="sh">'</span><span class="s">sgd</span><span class="sh">'</span><span class="s">.
        batch_size: (integer) number of training examples to use at each step.
        learning_rate: (float) learning rate for optimization.
        reg: (float) regularization strength for optimization.
        num_iters: (integer) number of steps to take when optimization.
        verbose: (boolean) if True, print out the progress (loss) when optimization.

        Returns
        -------
        losses_history: (list) of losses at each training iteration
        </span><span class="sh">"""</span>

        <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">num_classes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># assume y takes values 0...K-1 where K is number of classes
</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># initialize the weights with small values
</span>            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">Logistic</span><span class="sh">'</span><span class="p">:</span> <span class="c1"># just need weights for one class
</span>                <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># weigths for each class
</span>                <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>

        <span class="n">losses_history</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_iters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">bgd</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># randomly choose a min-batch of samples
</span>                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">num_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">)</span> <span class="c1"># grad =[K x D]
</span>            <span class="n">losses_history</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

            <span class="c1"># update weights
</span>            <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span> <span class="c1"># [K x D]
</span>            <span class="c1"># print self.W
</span>            <span class="c1"># print 'dsfad', grad.shape
</span>            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">print</span> <span class="sh">'</span><span class="s">iteration %d/%d: loss %f</span><span class="sh">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_iters</span><span class="p">,</span> <span class="n">loss</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">losses_history</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Predict value of y using trained weights

        Parameters
        ----------
        X: (D x N) array of data, each column is a sample with D-dimension.

        Returns
        -------
        pred_ys: (N, ) 1-dimension array of y for N sampels
        </span><span class="sh">"""</span>
        <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">Logistic</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">scores</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">()</span> <span class="o">=</span><span class="mi">0</span> 
        <span class="k">else</span><span class="p">:</span> <span class="c1"># multiclassification
</span>            <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_ys</span>

    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Compute the loss and gradients.

        Parameters
        ----------
        The same as self.train()

        Returns
        -------
        a tuple of two items (loss, grad)
        loss: (float)
        grad: (array) with respect to self.W
        </span><span class="sh">"""</span>
        <span class="k">pass</span>

<span class="c1">### Subclasses of linear classifier
</span><span class="k">class</span> <span class="nc">Logistic</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A subclass for binary classification using logistic function</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_logistic_vectorized</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_logistic_naive</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Softmax</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A subclass for multi-classicication using Softmax function</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_softmax_vectorized</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">loss_grad_softmax_naive</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span></code></pre></figure>

<p><strong>Function to compute loss and gradients for logistic classification: algorithms/classifiers/loss_grad_logistic.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># file: algorithms/classifiers/loss_grad_logistic.py
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">loss_grad_logistic_naive</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Compute the loss and gradients using logistic function 
    with loop, which is slow.

    Parameters
    ----------
    W: (1, D) array of weights, D is the dimension of one sample.
    X: (D x N) array of training data, each column is a training sample with D-dimension.
    y: (N, ) 1-dimension array of target data with length N.
    reg: (float) regularization strength for optimization.

    Returns
    -------
    a tuple of two items (loss, grad)
    loss: (float)
    grad: (array) with respect to self.W
    </span><span class="sh">"""</span>
    <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># [1, D]
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">):</span>
        <span class="n">sample_x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">f_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">sample_x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">f_x</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">h_x</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">f_x</span><span class="p">))</span>
        <span class="n">loss</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">h_x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h_x</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">loss</span>
        <span class="n">grad</span> <span class="o">+=</span> <span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">sample_x</span> <span class="c1"># [D, ]
</span>    <span class="n">loss</span> <span class="o">/=</span> <span class="n">num_train</span>
    <span class="n">loss</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span> <span class="c1"># add regularization
</span>
    <span class="n">grad</span> <span class="o">/=</span> <span class="n">num_train</span>
    <span class="n">grad</span> <span class="o">+=</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">W</span> <span class="c1"># add regularization
</span>    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span>

<span class="k">def</span> <span class="nf">loss_grad_logistic_vectorized</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Compute the loss and gradients with weights, vectorized version</span><span class="sh">"""</span>
    <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># [1, D]
</span>    <span class="c1"># print W
</span>    <span class="n">f_x_mat</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># [1, D] * [D, N]
</span>    <span class="n">h_x_mat</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">f_x_mat</span><span class="p">))</span> <span class="c1"># [1, N]
</span>    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">h_x_mat</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h_x_mat</span><span class="p">))</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_train</span> <span class="o">*</span> <span class="n">loss</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_x_mat</span> <span class="o">-</span> <span class="n">y</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># [1, D]
</span>    <span class="n">grad</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_train</span> <span class="o">*</span> <span class="n">grad</span> <span class="o">+</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">W</span>
    
    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span></code></pre></figure>

<p><strong>Function to compute loss and gradients for softmax classification: algorithms/classifiers/loss_grad_softmax.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># file: algorithms/classifiers/loss_grad_softmax.py
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">loss_grad_softmax_naive</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Compute the loss and gradients using softmax function 
    with loop, which is slow.

    Parameters
    ----------
    W: (K, D) array of weights, K is the number of classes and D is the dimension of one sample.
    X: (D, N) array of training data, each column is a training sample with D-dimension.
    y: (N, ) 1-dimension array of target data with length N with lables 0,1, ... K-1, for K classes
    reg: (float) regularization strength for optimization.

    Returns
    -------
    a tuple of two items (loss, grad)
    loss: (float)
    grad: (K, D) with respect to W
    </span><span class="sh">"""</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">):</span>
        <span class="n">sample_x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">num_classes</span><span class="p">)</span> <span class="c1"># [K, 1] unnormalized score
</span>        <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_classes</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">cls</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">scores</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">sample_x</span><span class="p">)</span>
        <span class="c1"># Shift the scores so that the highest value is 0
</span>        <span class="n">scores</span> <span class="o">-=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="n">correct_class</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sum_exp_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>

        <span class="n">corr_cls_exp_score</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">correct_class</span><span class="p">])</span>
        <span class="n">loss_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">corr_cls_exp_score</span> <span class="o">/</span> <span class="n">sum_exp_scores</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">+=</span> <span class="n">loss_x</span>

        <span class="c1"># compute the gradient
</span>        <span class="n">percent_exp_score</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_exp_scores</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_classes</span><span class="p">):</span>
            <span class="n">grad</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">percent_exp_score</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_x</span>


        <span class="n">grad</span><span class="p">[</span><span class="n">correct_class</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">sample_x</span> <span class="c1"># deal with the correct class
</span>
    <span class="n">loss</span> <span class="o">/=</span> <span class="n">num_train</span>
    <span class="n">loss</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span> <span class="c1"># add regularization
</span>    <span class="n">grad</span> <span class="o">/=</span> <span class="n">num_train</span>
    <span class="n">grad</span> <span class="o">+=</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">W</span>
    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span>

<span class="k">def</span> <span class="nf">loss_grad_softmax_vectorized</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Compute the loss and gradients using softmax with vectorized version</span><span class="sh">"""</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>

    <span class="n">scores</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># [K, N]
</span>    <span class="c1"># Shift scores so that the highest value is 0
</span>    <span class="n">scores</span> <span class="o">-=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
    <span class="n">scores_exp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
    <span class="n">correct_scores_exp</span> <span class="o">=</span> <span class="n">scores_exp</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="c1"># [N, ]
</span>    <span class="n">scores_exp_sum</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">scores_exp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># [N, ]
</span>    <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">correct_scores_exp</span> <span class="o">/</span> <span class="n">scores_exp_sum</span><span class="p">))</span>
    <span class="n">loss</span> <span class="o">/=</span> <span class="n">num_train</span>
    <span class="n">loss</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>

    <span class="n">scores_exp_normalized</span> <span class="o">=</span> <span class="n">scores_exp</span> <span class="o">/</span> <span class="n">scores_exp_sum</span>
    <span class="c1"># deal with the correct class
</span>    <span class="n">scores_exp_normalized</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># [K, N]
</span>    <span class="n">grad</span> <span class="o">=</span> <span class="n">scores_exp_normalized</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">/=</span> <span class="n">num_train</span>
    <span class="n">grad</span> <span class="o">+=</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">W</span>

    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span></code></pre></figure>

<h2 id="10-summary">10. Summary</h2>
<ul>
  <li>Logitic and softmax regression are similar and used to solve binary and multiple classification problems respectively. However, we can also use the logistic regression classifier to solve multi-classification based on one-vs-all trick.</li>
  <li>We should keep it in mind that logistic and softmax regression is based on the assumption that we can use a linear model to (roughly) distinguish different classes. So we should be very careful if we don’t known the distribution of the data.</li>
  <li>We use linear function to map the input X (such as image) to label scores y for each class: \(scores = f(x^{(i)}, W, b) = Wx{(i)} + b\). And then use the largest score for prediction.</li>
  <li>Normalizing the scores from 0 to 1. Im my opinion here is the most fundamental idea of the losgistic and softmax regression (function): that is we use a non-linear (exponential function) instead of linear function for normalization. It is reasonable to interprete that the bigger the score of one class is, the even more chance the sample belongs to that category, and the it is better to make derivative strictly increasing (exponential function is an appropriate condidate). Then we normalized the scores by computing the perentage of exponent score of each class in total exponent scores for all classes.</li>
  <li>As for loss function, the idea is to make the loss small when the normalized score is large, and penlize more when normalized score is small. it is not hard to figure out to using \(-log(x)\) function because we use exponential function to preprocess the scores.</li>
  <li>After defining the loss function, we can use the gradient descent algorithm to train the model.</li>
  <li>For implementation, it is critical to use matrix calculation, however it is not straightforward to transfer the naive loop version to vectorized version, which requires a very deep understanding of matrix multiplication. I’ve implemented the two algorithms to solve the CIFAR-10 dataset, and for test datasets I’ve got 82.95% accuracy for binary classification, 33.46% for all 10-classification using one-vs-all concept and 38.32% for all 10-classification using Softmax regression.</li>
</ul>

<h2 id="11-reference-and-further-reading">11. Reference and further reading</h2>
<ul>
  <li>Andrew Ng’s <a href="https://www.coursera.org/course/ml">Machine learning on Coursera</a></li>
  <li>Machine learing notes on <a href="http://see.stanford.edu/materials/aimlcs229/cs229-notes1.pdf">Stanford Engineering Everywhere (SEE)</a></li>
  <li>Stanford University open course <a href="http://vision.stanford.edu/teaching/cs231n/">CS231n</a></li>
  <li>The University of Nottingham <a href="http://modulecatalogue.nottingham.ac.uk/Nottingham/asp/moduledetails.asp?year_id=000113&amp;crs_id=021211">Machine Learning Module</a></li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[The details of using logistic and softmax algorithm for classification problem]]></summary></entry><entry><title type="html">Linear Regression</title><link href="http://houxianxu.github.io/blog/2015/linear-regression-post/" rel="alternate" type="text/html" title="Linear Regression" /><published>2015-03-31T00:00:00+00:00</published><updated>2015-03-31T00:00:00+00:00</updated><id>http://houxianxu.github.io/blog/2015/linear-regression-post</id><content type="html" xml:base="http://houxianxu.github.io/blog/2015/linear-regression-post/"><![CDATA[<blockquote>
  <p>This post dicusses how to come up with linear regression algorithm, specifically how to define the loss function and minimize the loss with gradient decent algorithm. I also implement the linear regression using Python (numpy) to do experiment with a datasets, and the result can be found in this <a href="http://houxianxu.github.io/implementation/LinearRegression.html">IPython notebook</a>.</p>
</blockquote>

<!-- more -->

<h2 id="1-problem-setting">1. Problem setting</h2>
<p>We want to use a <strong>predictor variable</strong> X to predict a <strong>quantitative response</strong> Y, such as using living area (X) to predict the price (Y) of house.</p>

<h2 id="2-basic-idea">2. Basic idea</h2>
<p>Becuase of just two variables, we can simply visualize the data on a scatter plot, then we can predict Y by the structure of the plot (see following figure)</p>

<p>After getting the scatter plot, we can estimate the position of potiential point when given the x value and get the corresponding value y.
<img src="http://houxianxu.github.io/assets/images/linearRegression/1.jpg" alt="Scatter Plot of Two variables" title="Figure 1" /></p>

<h2 id="3-can-we-do-better">3. Can we do better</h2>
<p>So far it seems that the problem can be solved, however, we shold always ask the quesion, i.e., “Can we do better?”</p>

<p>What’s the shortcoming of the above solution?</p>

<ul>
  <li>We have to firstly get the scatter plot, which is a problem when it scales to high dimension prediction problems.</li>
  <li>We need our human’s eyes to find the position of the position of potential point. We humans are not happy with that, instead we want the computer to do all the work. In addition, we can easily get overwhelmed when amounts of prediction needed.</li>
</ul>

<h2 id="4-better-idea">4. Better idea</h2>
<p>If we look at the structure of the scatter plot above, it is not hard to figure that the Y value is increasing when X gets bigger. So it is possible to find a model to fit all the data, then use the model instead for prediction.</p>

<p>Then what’s kind of model we should use? Linear model may be a good choice because of its simplicity and ability to show the general trend.</p>

<p>The next task is how to find the “best” line, such as \(y \) \(\approx\) \(f(x, w, b) =  w x + b, \) where w and b are the parameters of the function, in which w is called the <strong>weight</strong> and <strong>b</strong> is called bias, which doesn’t interact with the actual data \(x_i\). In order to find the “best” line, we need to define “best” and measure it. Ideally we hope \(y_i == f_i\) for every sample i, so we can use the difference or loss (\(|y_i - f_i|\), also called <strong>L1 distance</strong>) between the target \(y_i\) and predicted \(f_i\) for measurement for a single sample. When considering all the samples, we want to minimize the average loss \(\frac{1}{m} \sum_{i=1}^m|f_i - y_i|\) for all samples (m is the number of samples). Alternatively <strong>L2 distance</strong> can be used as well and the average loss is 
\(L_2 = \frac{1}{m} \sum_i^m(f_i - y_i)^2,\) of course other measurement could be used as well.</p>

<p>Next we need to find the w and b to minimize <strong>L_2(w, b)</strong>, i.e.  least-squares loss, which is an optimization problem. Because of quadratic formula, we can guess \(L_2\) is has bowl-shaped appearance in 3-dimension that \(L_2\) in fact is a <a href="http://stanford.edu/%7Eboyd/cvxbook/">convex function</a>. So based on college caculus，we can compute the partial derivative of w and b, then set them to be zero and compute the w and b (the bottom of the shape).</p>

\[\begin{cases}\frac{\partial L_2}{\partial w} = \frac{\partial f(x, w, b)}{\partial w} = 0 \\ \frac{\partial L_2}{\partial b} = \frac{\partial f(x, w, b)}{\partial w} = 0 \end{cases}\]

<p>Above approach directly compute the best w and b based on the property of convex function, and we could ask ourselves is there other ways (say indirectly) to get w and b? Maybe we could firstly inilize w and b randomly, and then try to make it better little by little. By analogy, a blind hiker tries his best to reach the bottom of a hill, specifically try to take a step at every point.</p>

<ul>
  <li>The first approach (Random Local Search) could be try to extend on foot in a random direction and take a step only if it leads down hill.</li>
  <li>Another better way is to follow the direction of steepest decend, which is the <strong>gradient</strong> or <strong>derivative</strong> of loss function at one point, and the w and b can be updated by following the best direction (gradient) and a given step (known as learning rate). Obviously the learning rate will have big impact on our algorithm; we can only get a very small progress if learing rate is too small, however when making a bigger step, we may get a higher loss because the point maybe jump to the other side of the bowl-shaped line. So we could do some research here, e.g. how to decide the learning rate (try different values with validation method), maybe we could make it dynamically. Another potential problem here is that we use all the samples to complish just one update when taking compulation complex into account. One solution is to update the parameters according to the gradient of the error with respect to one single training example only. This alogrithm is called <strong>stochastic gradient descent</strong> or <strong>online gradient decent</strong>, and <strong>batch gradient descent</strong> for previous one. SGD often gets “close” to the minimum much faster than BGD, however it may never “converge” to the minimum. Another bonus is that it is possible to ensure that the parameters will converge to the global minimum rather then merely oscillate around the minimum.</li>
</ul>

<h2 id="5-genralization-for-high-dimension-data">5. Genralization for high dimension data</h2>
<p>When there are more than 1 predictor variable, we just need to change the model as \(y \approx f(x, w, b) = \sum_{j=1}^n x_j w_j + b = w^T x + b\) (w and x are vector, and n is the number of features), in fact we can make the expression more compact by setting b = \(w_0\) and \(x_0 = 1\), then \(f(x, w) = w^T x.\)</p>

<p>The loss \(L = \frac{1}{2m} \sum_{i=1}^m(f(x^{(i)}, w) - y^{(i)})^2\), where \(x^{(i)}\) is a vector for all features \(x_j^{(i)}\) (j=0,1, … , n) for single sample i, and \(y^{(i)}\) is the target value for this example.</p>

<p>Compute the gradient for all w:</p>

<ul>
  <li>Analytic gradient, using calculus to compute the gradient directly</li>
</ul>

\[\begin{equation}
	 \begin{split} 
	 \frac{\partial}{\partial w_j} L(w, x) &amp;= \frac{\partial}{\partial w_j}  \frac{1}{2m} \sum_{i=1}^m  (f(x^{(i)}, w) 											  - y^{(i)})^2 \\ 
	 									   &amp;= \frac{1}{2m} \frac{\partial}{\partial w_j} \sum_{i=1}^m [(w_0 x_0^{(i)} + 	w_1 x_1^{(i)} + ... + w_n x_n^{(i)}) - y^{(i)}]^2 \\
	 									   &amp;= \frac{1}{m} \sum_{i=1}^m  (f(x^{(i)}, w) 											  - y^{(i)}) x_j^{(i)}
	\end{split}
	\end{equation}\]

<ul>
  <li>Numerical gradient, which is an approximation approach based on the definition of derivatives (or gradient). The derivative of a 1-D function is the limit of the function with respect its input. When the function takes more than one parameters, the derivatives are called partial derivatives.</li>
</ul>

\[\frac{df(x)}{dx} = \lim_{h \rightarrow 0}  \frac{f(x + h) - f(x)}{h} = \lim_{h \rightarrow 0}  \frac{f(x + h) - f(x - h)}{2h}\]

<p>Update w by gradient decient: \(w_j := w_j - \alpha \frac{\partial}{\partial w_j} L(w, x)\), this regression is also called <strong>LMS</strong> standing for “least mean squares”.</p>

<p>Compared with two dimension model that is a line in 2-D space, we can look on n-dimension model as a n-hyperplane (subspace) in (n+1)-D space, e.g. a plane in a 3-D space.</p>

<h2 id="6-probabilistic-interpretation">6. Probabilistic interpretation</h2>
<p>After understanding LMS regression above, we should again ask “Can we do better?”. I think the key or foundation of above is the least-square loss function \(L_2 = \frac{1}{m} \sum_i^m(f_i - y_i)^2\). So why this is a reasonable choice?</p>

<p>Because we just use f(w, x) to <strong>estimate</strong> the target y and <strong>expectation</strong> is often used for estimation, so we can interpret \(f(w, x^{(i)}) = w^T x^{(i)}\) as the expectation of estimation. So we could add an error term \(\epsilon^{(i)}\) to previous experession, as a result \(y = w^T x^{(i)} + \epsilon^{(i)}\). Because the expectation could be higher or less than the target value, we could even assume all \(\epsilon^{(i)}\) are distributed IID (independently and identically distributed) according to a Gaussian Distribution (also called a Normal distribution) with mean zero and some variance \(\sigma^2\), i.e., \(\epsilon^{(i)} \sim \mathcal{N} (0,\sigma^2)\), so \(y^{(i)} \sim \mathcal{N} (w^T x^{(i)},\sigma^2)\)</p>

<p>So far when given a vector <strong>w</strong> and all <strong>\(x_j\)</strong>, we can compute the probability of \(y^{(i)}\) from the Gaussian Distribution. Naturally we want the maximize all the probability of \(y^{(i)}\) at the same time, and this method is called maximum likelihood. The corresponding likelihood function is</p>

\[L(w; x) =  \prod_{i = i}^m \frac{1}{\sqrt{2 \, \pi} \sigma} exp({-\frac{(y^{(i)} - w^T x^{(i)})^2}{2 \sigma^2}})\]

<p>Instead of maximizing \(L(w; x)\), we can also maximize any strictly increasing function of \(L(w; x)\), naturally we can instead maximize likelihood \(l(w; x)\)</p>

\[\begin{equation}
	\begin{split} 
	l(w; x) &amp;= L(w; x) \\
				&amp;= \log \prod_{i = i}^m \frac{1}{\sqrt{2 \, \pi} \sigma} exp({-\frac{(y^{(i)} - w^T x^{(i)})^2}{2 \sigma^2}}) \\
				&amp;= \sum_{i=1}^m \log \frac{1}{\sqrt{2 \, \pi} \sigma} exp({-\frac{(y^{(i)} - w^T x^{(i)})^2}{2 \sigma^2}}) \\
				&amp;= m \log \frac{1}{\sqrt{2 \, \pi} \sigma} - \frac{1}{\sigma^2} \frac{1}{2} \sum_{i=1}^m (y^{(i)} - w^T x^{(i)})^2
\end{split}
	\end{equation}\]

<p>Because w are the only unknown parameters (assume \(\sigma\) is known), we need only to minimize the second item \(\frac{1}{\sigma^2} \frac{1}{2} \sum_{i=1}^m (y^{(i)} - w^T x^{(i)})^2\), which could be viewed as less-square loss.</p>

<p>When we see \(\sigma\) as the unknown parameter, we could also calculate the “best” \(\sigma\) to maximize the likelihood. I think the assumption that all the point have the same \(\sigma\) is too strong to some degree, so if they are not the same and depend on X, we can get a different loss function.</p>

<h2 id="7-get-your-hands-dirty-and-have-fun">7. Get your hands dirty and have fun</h2>

<ul>
  <li>Data: I use the data from linear regression exercise from Andrew Ng’s <a href="https://www.coursera.org/course/ml">Machine learning on Coursera</a>.</li>
  <li>Setup: I choose Python (IPython, numpy etc.) on Mac for implementation, and the results are published in a IPython notebook, <a href="http://houxianxu.github.io/implementation/LinearRegression.html">click here </a> for the details</li>
  <li>Following is code to implement the batch and stochastic gradient decent algorithms.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">LinearRegression</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># set the weight vector
</span>
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">bgd</span><span class="sh">'</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Train linear regression using batch gradient descent or stochastic gradient descent

        Parameters
        ----------
        X: (D x N) array of training data, each column is a training sample with D-dimension.
        y: (N, ) 1-dimension array of target data with length N. 
        method: (string) determine wheter use </span><span class="sh">'</span><span class="s">bgd</span><span class="sh">'</span><span class="s"> or </span><span class="sh">'</span><span class="s">sgd</span><span class="sh">'</span><span class="s">
        learning_rate: (float) learning rate for optimization
        num_iters: (integer) number of steps to take when optimization
        verbose: (boolean) if True, print out the progress when optimization

        Returns
        -------
        losses_history: (list) of losses at each training iteration
        </span><span class="sh">"""</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># initilize weights with small values
</span>            <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span> <span class="c1"># [1, D]
</span>        <span class="n">losses_history</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_iters</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">sgd</span><span class="sh">'</span><span class="p">:</span>
                <span class="c1"># randomly choose a sample
</span>                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">num_train</span><span class="p">)</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">loss_grad</span><span class="p">(</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">losses_history</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

            <span class="c1"># Update weights using matrix computing (vectorized)
</span>            <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_iters</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span> <span class="sh">'</span><span class="s">iteration %d / %d : loss %f</span><span class="sh">'</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_iters</span><span class="p">,</span> <span class="n">loss</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">losses_history</span>


    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Predict value of y using trained weights

        Parameters
        ----------
        X: (D x N) array of data, each column is a sample with D-dimension.

        Returns
        -------
        pred_ys: (N, ) 1-dimension array of y for N sampels
        </span><span class="sh">"""</span>
        <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_ys</span>


    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Compute the loss and gradients

        Parameters
        ----------
        The same as self.train function

        Returns
        -------
        a tuple of two items (loss, grad)
        loss: (float)
        grad: (array) with respect to self.W 
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">linear_loss_grad</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">linear_loss_grad_naive</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">linear_loss_grad</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Compute the loss and gradients with weights, vectorized version

    Parameters and Returns are the same as LinearRegression.loss_grad, except including W as parameter
    </span><span class="sh">"""</span>
    <span class="c1"># vectorized implementation 
</span>    <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f_mat</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># [1, D] * [D, N]
</span>    <span class="n">diff</span> <span class="o">=</span> <span class="n">f_mat</span> <span class="o">-</span> <span class="n">y</span> <span class="c1"># [1, N] - [1, N]
</span>    <span class="n">loss</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_train</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span> <span class="c1"># [1, N] * [N, 1] 
</span>    <span class="n">grad</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_train</span> <span class="o">*</span> <span class="n">diff</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># [1, N] * [N, D]
</span>    <span class="nf">return </span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">linear_loss_grad_naive</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Compute the loss and gradients with weights, for loop version
    </span><span class="sh">"""</span>
    <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># [1, D]
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">):</span>
        <span class="n">sample_X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="c1"># a vector
</span>        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="n">sample_X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">loss</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">sample_X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            
    <span class="n">loss</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_train</span><span class="p">)</span> <span class="o">*</span> <span class="n">loss</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_train</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="8-summary">8. Summary</h2>
<ul>
  <li>We all should keep it in mind that linear regression is based on the assumption that the true model is linear or close to linear, so we should be very careful if we don’t known the true model in advance.</li>
  <li>Most people use least square error to indicate the loss of the linear model and it can be interpretated from  probabilistic aspect, i.e., assuming that the errors are distributed IID according to a Gaussian Distribution, the probability of y based on x (<code class="language-plaintext highlighter-rouge">p(y|x)</code>) for all the samples can be maximized to minimize the least square error. Of course, we can choose other loss function as long as it makes sense to measure the agreement between the predicted scores and the ground truth value.</li>
  <li>We can use normal equation \(W = (X^T X)^{-1} X^T y\) to compute W directly based on calculus, however it works slow when n is large, instead, gradient decent algorithm is more practical based on the bowl-shape of loss function. The basic idea is to reduce the loss step by step.</li>
  <li>For implementation, it is critical to use matrix calculation. Not only can it speed up the computation, but also can make code simpler and conciser when compared to naive loop version.</li>
</ul>

<h2 id="9-reference-and-further-reading">9. Reference and further reading</h2>
<ul>
  <li>Andrew Ng’s <a href="https://www.coursera.org/course/ml">Machine learning on Coursera</a></li>
  <li>Andrew Ng’s machine learing notes on <a href="http://see.stanford.edu/materials/aimlcs229/cs229-notes1.pdf">Stanford Engineering Everywhere (SEE)</a></li>
  <li><a href="http://modulecatalogue.nottingham.ac.uk/Nottingham/asp/moduledetails.asp?year_id=000113&amp;crs_id=021211">Machine Learning Module</a> in the University of Nottingham</li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[The basic linear regression algorithm]]></summary></entry><entry><title type="html">Why and How I Write This Blog</title><link href="http://houxianxu.github.io/blog/2015/first-blog/" rel="alternate" type="text/html" title="Why and How I Write This Blog" /><published>2015-03-16T20:00:00+00:00</published><updated>2015-03-16T20:00:00+00:00</updated><id>http://houxianxu.github.io/blog/2015/first-blog</id><content type="html" xml:base="http://houxianxu.github.io/blog/2015/first-blog/"><![CDATA[<h2 id="purpose-of-this-blog">Purpose of this blog</h2>
<p>The main reason that I want to set up this blog is to help me study machine learning and do research in this area. I believe that it is a very good habit to rethink and rewrite my own interpretation of what I have learned.</p>

<p>Because of non-cs background, I think it is also an wonderful opportunity to learn something new in CS such as front-end technologies.</p>

<h2 id="logic-behind-every-post">Logic behind every post</h2>
<p>Most posts will discuss machine algorithms, of course, there are many good books and tutorials introducing these. However, what I want to do is not just to introduce the algorithms, instead I assume that one algorithm had not been invented by predecessors, would we be able to come up with the algorithm?</p>

<p>I think this kind of assumption could be very helpful to study and do research. The emphasis is about how the algorithm was invented (how to think), not just the algorithm itself. It is like “supervised learning” because the result of algorithm in fact is known to us, so we can use the result to supervise us to learn one algorithm and we can always ask ourselves why I can’t come up with this amazing solution.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Just start blogging :)]]></summary></entry></feed>